call: from tinygrad.tensor import Tensor                            # noqa: F401
line: from tinygrad.tensor import Tensor                            # noqa: F401
call: # inspired by https://github.com/karpathy/micrograd/blob/master/micrograd/engine.py
line: from __future__ import annotations
line: import dataclasses
line: import time, math, itertools, functools, struct, sys, inspect
line: from contextlib import ContextDecorator
line: from typing import List, Tuple, Callable, Optional, ClassVar, Type, Union, Sequence, Dict, DefaultDict, cast, get_args, Set
line: from collections import defaultdict
line: import numpy as np
line: from tinygrad.dtype import DType, dtypes, ImageDType, ConstType, least_upper_float, least_upper_dtype, sum_acc_dtype
call: from typing import Final, Optional, ClassVar, Set, Tuple, Dict, Union
line: from typing import Final, Optional, ClassVar, Set, Tuple, Dict, Union
line: from dataclasses import dataclass
line: import functools
line: from tinygrad.helpers import getenv
call: from __future__ import annotations
line: from __future__ import annotations
line: import os, functools, platform, time, re, contextlib, operator, hashlib, pickle, sqlite3, cProfile, pstats, tempfile, pathlib, string, ctypes, sys
line: import itertools, urllib.request, subprocess, shutil, math, json, contextvars
line: from dataclasses import dataclass
line: from typing import Dict, Tuple, Union, List, ClassVar, Optional, Iterable, Any, TypeVar, TYPE_CHECKING, Callable, Sequence
line: if TYPE_CHECKING:  # TODO: remove this and import TypeGuard from typing once minimum python supported version is 3.10
line: T = TypeVar("T")
line: U = TypeVar("U")
line: def prod(x:Iterable[T]) -> Union[T,int]: return functools.reduce(operator.mul, x, 1)
line: OSX = platform.system() == "Darwin"
line: CI = os.getenv("CI", "") != ""
line: def dedup(x:Iterable[T]): return list(dict.fromkeys(x))   # retains list order
line: def argfix(*x):
line: def argsort(x): return type(x)(sorted(range(len(x)), key=x.__getitem__)) # https://stackoverflow.com/questions/3382352/equivalent-of-numpy-argsort-in-basic-python
line: def all_same(items:List[T]): return all(x == items[0] for x in items)
line: def all_int(t: Sequence[Any]) -> TypeGuard[Tuple[int, ...]]: return all(isinstance(s, int) for s in t)
line: def colored(st, color:Optional[str], background=False): return f"\u001b[{10*background+60*(color.upper() == color)+30+['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'].index(color.lower())}m{st}\u001b[0m" if color is not None else st  # replace the termcolor library with one line  # noqa: E501
line: def colorize_float(x: float): return colored(f"{x:7.2f}x", 'green' if x < 0.75 else 'red' if x > 1.15 else 'yellow')
line: def ansistrip(s:str): return re.sub('\x1b\\[(K|.*?m)', '', s)
line: def ansilen(s:str): return len(ansistrip(s))
line: def make_pair(x:Union[int, Tuple[int, ...]], cnt=2) -> Tuple[int, ...]: return (x,)*cnt if isinstance(x, int) else x
line: def flatten(l:Iterable[Iterable[T]]): return [item for sublist in l for item in sublist]
line: def fully_flatten(l): return [item for sublist in l for item in (fully_flatten(sublist) if isinstance(sublist, (tuple, list)) else [sublist])]
line: def fromimport(mod, frm): return getattr(__import__(mod, fromlist=[frm]), frm)
line: def strip_parens(fst:str): return fst[1:-1] if fst[0] == '(' and fst[-1] == ')' and fst[1:-1].find('(') <= fst[1:-1].find(')') else fst
line: def round_up(num, amt:int): return (num+amt-1)//amt * amt
line: def merge_dicts(ds:Iterable[Dict[T,U]]) -> Dict[T,U]:
line: def partition(lst:List[T], fxn:Callable[[T],bool]) -> Tuple[List[T], List[T]]:
line: def unwrap(x:Optional[T]) -> T:
line: def unwrap2(x:Tuple[T,Any]) -> T:
line: def get_child(obj, key):
line: def get_shape(x) -> Tuple[int, ...]:
line: def get_contraction(old_shape:Tuple[sint, ...], new_shape:Tuple[sint, ...]) -> Optional[List[List[int]]]:
line: @functools.lru_cache(maxsize=None)
line: def to_function_name(s:str): return ''.join([c if c in (string.ascii_letters+string.digits+'_') else f'{ord(c):02X}' for c in ansistrip(s)])
line: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line: def temp(x:str) -> str: return (pathlib.Path(tempfile.gettempdir()) / x).as_posix()
line: class GraphException(Exception): pass
call: class GraphException(Exception): pass
line: class GraphException(Exception): pass
retu: class GraphException(Exception): pass
line: class Context(contextlib.ContextDecorator):
call: class Context(contextlib.ContextDecorator):
line: class Context(contextlib.ContextDecorator):
line:   stack: ClassVar[List[dict[str, int]]] = [{}]
line:   def __init__(self, **kwargs): self.kwargs = kwargs
line:   def __enter__(self):
line:   def __exit__(self, *args):
retu:   def __exit__(self, *args):
line: class ContextVar:
call: class ContextVar:
line: class ContextVar:
line:   _cache: ClassVar[Dict[str, ContextVar]] = {}
line:   value: int
line:   key: str
line:   def __new__(cls, key, default_value):
line:   def __bool__(self): return bool(self.value)
line:   def __ge__(self, x): return self.value >= x
line:   def __gt__(self, x): return self.value > x
line:   def __lt__(self, x): return self.value < x
retu:   def __lt__(self, x): return self.value < x
line: DEBUG, IMAGE, BEAM, NOOPT, JIT = ContextVar("DEBUG", 0), ContextVar("IMAGE", 0), ContextVar("BEAM", 0), ContextVar("NOOPT", 0), ContextVar("JIT", 1)
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
line: WINO, THREEFRY, CAPTURING, TRACEMETA = ContextVar("WINO", 0), ContextVar("THREEFRY", 0), ContextVar("CAPTURING", 1), ContextVar("TRACEMETA", 1)
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
line: GRAPH, GRAPHPATH, SAVE_SCHEDULE, RING = ContextVar("GRAPH", 0), getenv("GRAPHPATH", "/tmp/net"), ContextVar("SAVE_SCHEDULE", 0), ContextVar("RING", 1)
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
line: MULTIOUTPUT, PROFILE, TRANSCENDENTAL = ContextVar("MULTIOUTPUT", 1), ContextVar("PROFILE", 0), ContextVar("TRANSCENDENTAL", 1)
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
line: USE_TC, TC_OPT = ContextVar("TC", 1), ContextVar("TC_OPT", 0)
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
line: FUSE_AS_ONE_KERNEL = ContextVar("FUSE_AS_ONE_KERNEL", 0)
call:   def __new__(cls, key, default_value):
line:     if key in ContextVar._cache: return ContextVar._cache[key]
line:     instance = ContextVar._cache[key] = super().__new__(cls)
line:     instance.value, instance.key = getenv(key, default_value), key
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:     return instance
retu:     return instance
line: @dataclass(frozen=True)
line: class Metadata:
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   name: str
line:   caller: str
line:   backward: bool = False
line:   def __hash__(self): return hash(self.name)
line:   def __repr__(self): return str(self) + (f" - {self.caller}" if self.caller else "")
line:   def __str__(self): return self.name + (" bw" if self.backward else "")
retu:   def __str__(self): return self.name + (" bw" if self.backward else "")
line: _METADATA: contextvars.ContextVar[Optional[Metadata]] = contextvars.ContextVar("_METADATA", default=None)
line: class GlobalCounters:
call: class GlobalCounters:
line: class GlobalCounters:
line:   global_ops: ClassVar[int] = 0
line:   global_mem: ClassVar[int] = 0
line:   time_sum_s: ClassVar[float] = 0.0
line:   kernel_count: ClassVar[int] = 0
line:   mem_used: ClassVar[int] = 0   # NOTE: this is not reset
line:   @staticmethod
line:   def reset(): GlobalCounters.global_ops, GlobalCounters.global_mem, GlobalCounters.time_sum_s, GlobalCounters.kernel_count = 0,0,0.0,0
retu:   def reset(): GlobalCounters.global_ops, GlobalCounters.global_mem, GlobalCounters.time_sum_s, GlobalCounters.kernel_count = 0,0,0.0,0
line: class Timing(contextlib.ContextDecorator):
call: class Timing(contextlib.ContextDecorator):
line: class Timing(contextlib.ContextDecorator):
line:   def __init__(self, prefix="", on_exit=None, enabled=True): self.prefix, self.on_exit, self.enabled = prefix, on_exit, enabled
line:   def __enter__(self): self.st = time.perf_counter_ns()
line:   def __exit__(self, *exc):
retu:   def __exit__(self, *exc):
line: def _format_fcn(fcn): return f"{fcn[0]}:{fcn[1]}:{fcn[2]}"
line: class Profiling(contextlib.ContextDecorator):
call: class Profiling(contextlib.ContextDecorator):
line: class Profiling(contextlib.ContextDecorator):
line:   def __init__(self, enabled=True, sort='cumtime', frac=0.2, fn=None, ts=1):
line:   def __enter__(self):
line:   def __exit__(self, *exc):
retu:   def __exit__(self, *exc):
line: class ProfileLogger:
call: class ProfileLogger:
line: class ProfileLogger:
line:   writers: int = 0
line:   mjson: List[Dict] = []
line:   actors: Dict[str, int] = {}
line:   subactors: Dict[Tuple[str, str], int] = {}
line:   path = getenv("PROFILE_OUTPUT_FILE", temp("tinygrad_profile.json"))
call: def temp(x:str) -> str: return (pathlib.Path(tempfile.gettempdir()) / x).as_posix()
line: def temp(x:str) -> str: return (pathlib.Path(tempfile.gettempdir()) / x).as_posix()
retu: def temp(x:str) -> str: return (pathlib.Path(tempfile.gettempdir()) / x).as_posix()
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:   def __init__(self): self.events, ProfileLogger.writers = [], ProfileLogger.writers + 1
line:   def add_event(self, ev_name, ev_start, ev_end, actor, subactor=None): self.events += [(ev_name, ev_start, ev_end, actor, subactor)]
line:   def __del__(self):
retu:   def __del__(self):
line: _cache_dir: str = getenv("XDG_CACHE_HOME", os.path.expanduser("~/Library/Caches" if OSX else "~/.cache"))
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line: CACHEDB: str = getenv("CACHEDB", os.path.abspath(os.path.join(_cache_dir, "tinygrad", "cache.db")))
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line: CACHELEVEL = getenv("CACHELEVEL", 2)
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line: VERSION = 16
line: _db_connection = None
line: def db_connection():
line: def diskcache_clear():
line: def diskcache_get(table:str, key:Union[Dict, str, int]) -> Any:
line: _db_tables = set()
line: def diskcache_put(table:str, key:Union[Dict, str, int], val:Any):
line: def diskcache(func):
line: def fetch(url:str, hamedi=getenv("HAMEDI", 0), name:Optional[Union[pathlib.Path, str]]=None, subdir:Optional[str]=None,
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:           allow_caching=not getenv("DISABLE_HTTP_CACHE")) -> pathlib.Path:
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line: def fetch(url:str, hamedi=getenv("HAMEDI", 0), name:Optional[Union[pathlib.Path, str]]=None, subdir:Optional[str]=None,
line: def cpu_time_execution(cb, enable):
line: def cpu_objdump(lib):
line: def from_mv(mv:memoryview, to_type=ctypes.c_char):
line: def to_mv(ptr, sz) -> memoryview: return memoryview(ctypes.cast(ptr, ctypes.POINTER(ctypes.c_uint8 * sz)).contents).cast("B")
line: def mv_address(mv:memoryview): return ctypes.addressof(ctypes.c_char.from_buffer(mv))
line: def to_char_p_p(options: List[bytes], to_type=ctypes.c_char): return (ctypes.POINTER(to_type) * len(options))(*[ctypes.cast(ctypes.create_string_buffer(o), ctypes.POINTER(to_type)) for o in options])  # noqa: E501
line: @functools.lru_cache(maxsize=None)
line: def init_c_struct_t(fields: Tuple[Tuple[str, ctypes._SimpleCData], ...]):
line: def init_c_var(ctypes_var, creat_cb): return (creat_cb(ctypes_var), ctypes_var)[1]
line: def flat_mv(mv:memoryview): return mv if len(mv) == 0 else mv.cast("B", shape=(mv.nbytes,))
line: class tqdm:
call: class tqdm:
line: class tqdm:
line:   def __init__(self, iterable=None, desc:str='', disable:bool=False, unit:str='it', unit_scale=False, total:Optional[int]=None, rate:int=100):
line:   def __iter__(self):
line:   def set_description(self, desc:str): self.desc = f"{desc}: " if desc else ""
line:   def update(self, n:int=0, close:bool=False):
retu:   def update(self, n:int=0, close:bool=False):
line: class trange(tqdm):
call: class trange(tqdm):
line: class trange(tqdm):
line:   def __init__(self, n:int, **kwargs): super().__init__(iterable=range(n), total=n, **kwargs)
retu:   def __init__(self, n:int, **kwargs): super().__init__(iterable=range(n), total=n, **kwargs)
line: def pretty_print(x:Any, rep:Callable, srcfn=lambda x: x.src, cache=None, d=0)->str:
retu: def pretty_print(x:Any, rep:Callable, srcfn=lambda x: x.src, cache=None, d=0)->str:
line: ConstType = Union[float, int, bool]
line: @dataclass(frozen=True, order=True)
line: class DType:
call: @dataclass(frozen=True, order=True)
line: @dataclass(frozen=True, order=True)
line:   priority: int  # this determines when things get upcasted
line:   itemsize: int
line:   name: str
line:   fmt: Optional[str]
line:   count: int
line:   def __repr__(self): return f"dtypes.{'_'*(c:=self.count!=1)}{INVERSE_DTYPES_DICT[self.name if not c else self.scalar().name]}{str(self.count)*c}"
line:   def vec(self, sz:int):
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line: @dataclass(frozen=True, repr=False)
line: class ImageDType(DType):
call: @dataclass(frozen=True, repr=False)
line: @dataclass(frozen=True, repr=False)
line:   shape: Tuple[int, ...]   # arbitrary arg for the dtype, used in image for the shape
line:   base: DType
line:   def scalar(self): return self.base
line:   def vec(self, sz:int): return self.base.vec(sz)
line:   def __repr__(self): return f"dtypes.{self.name}({self.shape})"
retu:   def __repr__(self): return f"dtypes.{self.name}({self.shape})"
line: class PtrDType(DType):
call: class PtrDType(DType):
line: class PtrDType(DType):
line:   def __init__(self, dt:DType): super().__init__(dt.priority, dt.itemsize, dt.name, dt.fmt, dt.count)
line:   def __hash__(self): return super().__hash__()
line:   def __eq__(self, dt): return self.priority==dt.priority and self.itemsize==dt.itemsize and self.name==dt.name and self.count==dt.count
line:   def __ne__(self, dt): return not (self == dt)
line:   def __repr__(self): return f"PtrDType({super().__repr__()})"
retu:   def __repr__(self): return f"PtrDType({super().__repr__()})"
line: class dtypes:
call: class dtypes:
line: class dtypes:
line:   @staticmethod
line:   def is_float(x: DType) -> bool: return x.scalar() in (dtypes.float16, dtypes.bfloat16, dtypes.float32, dtypes.float64)
line:   @staticmethod # static methds on top, or bool in the type info will refer to dtypes.bool
line:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
line:   @staticmethod
line:   def is_unsigned(x: DType) -> bool: return x.scalar() in (dtypes.uint8, dtypes.uint16, dtypes.uint32, dtypes.uint64)
line:   @staticmethod
line:   def from_py(x) -> DType:
line:   @staticmethod
line:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
line:   @staticmethod
line:   def min(dtype:DType):
line:   @staticmethod
line:   def max(dtype:DType):
line:   @staticmethod
line:   def fields() -> Dict[str, DType]: return DTYPES_DICT
line:   bigint: Final[DType] = DType(-1, 0, "bigint", None, 1)   # arbitrary precision integer
line:   bool: Final[DType] = DType(0, 1, "bool", '?', 1)
line:   int8: Final[DType] = DType(1, 1, "char", 'b', 1)
line:   uint8: Final[DType] = DType(2, 1, "unsigned char", 'B', 1)
line:   int16: Final[DType] = DType(3, 2, "short", 'h', 1)
line:   uint16: Final[DType] = DType(4, 2, "unsigned short", 'H', 1)
line:   int32: Final[DType] = DType(5, 4, "int", 'i', 1)
line:   uint32: Final[DType] = DType(6, 4, "unsigned int", 'I', 1)
line:   int64: Final[DType] = DType(7, 8, "long", 'l', 1)
line:   uint64: Final[DType] = DType(8, 8, "unsigned long", 'L', 1)
line:   float16: Final[DType] = DType(9, 2, "half", 'e', 1)
line:   bfloat16: Final[DType] = DType(10, 2, "__bf16", None, 1)
line:   float32: Final[DType] = DType(11, 4, "float", 'f', 1)
line:   float64: Final[DType] = DType(12, 8, "double", 'd', 1)
line:   half = float16; float = float32; double = float64 # noqa: E702
line:   uchar = uint8; ushort = uint16; uint = uint32; ulong = uint64 # noqa: E702
line:   char = int8; short = int16; int = int32; long = int64 # noqa: E702
line:   @staticmethod
line:   def imageh(shp): return ImageDType(100, 2, "imageh", 'e', 1, shape=shp, base=dtypes.float32)
line:   @staticmethod
line:   def imagef(shp): return ImageDType(100, 4, "imagef", 'f', 1, shape=shp, base=dtypes.float32)
line:   default_float: ClassVar[DType] = float32
line:   default_int: ClassVar[DType] = int32
retu:   default_int: ClassVar[DType] = int32
line: if (env_default_float := getenv("DEFAULT_FLOAT", "")):
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line: promo_lattice = { dtypes.bool: [dtypes.int8, dtypes.uint8], dtypes.int8: [dtypes.int16], dtypes.int16: [dtypes.int32], dtypes.int32: [dtypes.int64],
line:   dtypes.int64: [dtypes.float16, dtypes.bfloat16], dtypes.uint8: [dtypes.int16, dtypes.uint16], dtypes.uint16: [dtypes.int32, dtypes.uint32],
line:   dtypes.uint32: [dtypes.int64, dtypes.uint64], dtypes.uint64: [dtypes.float16, dtypes.bfloat16],
line:   dtypes.float16: [dtypes.float32], dtypes.bfloat16: [dtypes.float32], dtypes.float32: [dtypes.float64], }
line: promo_lattice = { dtypes.bool: [dtypes.int8, dtypes.uint8], dtypes.int8: [dtypes.int16], dtypes.int16: [dtypes.int32], dtypes.int32: [dtypes.int64],
line: @functools.lru_cache(None)
line: def _get_recursive_parents(dtype:DType) -> Set[DType]:
line: @functools.lru_cache(None)
line: def least_upper_dtype(*ds:DType) -> DType:
line: def least_upper_float(dt:DType) -> DType: return dt if dtypes.is_float(dt) else least_upper_dtype(dt, dtypes.float32)
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
call: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
retu: DTYPES_DICT = {k: v for k, v in dtypes.__dict__.items() if not (k.startswith(('__', 'default', 'bigint')) or v.__class__ is staticmethod)}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
call: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
retu: INVERSE_DTYPES_DICT = {v.name:k for k,v in DTYPES_DICT.items()}
line: INVERSE_DTYPES_DICT['bigint'] = 'bigint'
line: def sum_acc_dtype(dt:DType):
retu: def sum_acc_dtype(dt:DType):
line: from tinygrad.helpers import argfix, make_pair, flatten, prod, all_int, round_up, merge_dicts, argsort, getenv, get_shape, fully_flatten, dedup
line: from tinygrad.helpers import IMAGE, DEBUG, WINO, THREEFRY, _METADATA, Metadata, TRACEMETA
line: from tinygrad.lazy import LazyBuffer
call: from __future__ import annotations
line: from __future__ import annotations
line: from typing import Union, Optional, Any, Tuple, List
line: from tinygrad.dtype import dtypes, DType, ConstType
line: from tinygrad.helpers import prod, getenv, all_int, all_same, DEBUG, _METADATA, Metadata
line: from tinygrad.ops import MetaOps, UnaryOps, BinaryOps, TernaryOps, ReduceOps, Op, exec_alu, python_alu, reduce_st
call: from __future__ import annotations
line: from __future__ import annotations
line: from typing import Union, Tuple, Any, List, Dict, Callable
line: import functools, hashlib, math, operator, ctypes, struct
line: from enum import Enum, auto
line: from dataclasses import dataclass
line: from tinygrad.helpers import dedup, pretty_print
line: from tinygrad.dtype import dtypes, DType, ConstType
line: from tinygrad.shape.symbolic import Variable, sint
call: from __future__ import annotations
line: from __future__ import annotations
line: import functools
line: from math import gcd
line: from tinygrad.helpers import partition
line: from typing import List, Dict, Callable, Tuple, Type, Union, Optional, Any, Set, Mapping
line: class Node:
call: class Node:
line: class Node:
line:   b: Union[Node, int]
line:   min: int
line:   max: sint
line:   def render(self, ops=None, ctx=None) -> Any:
line:   def vars(self) -> Set[Variable]: return set()
line:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node: raise RuntimeError(self.__class__.__name__)
line:   def unbind(self) -> Tuple[Node, Optional[int]]: return self.substitute({v: v.unbind()[0] for v in self.vars() if v.val is not None}), None
line:   @functools.cached_property
line:   def key(self) -> str: return self.render(ctx="DEBUG")
line:   def __repr__(self): return self.render(ctx="REPR")
line:   def __str__(self): return "<"+self.key+">"
line:   def __hash__(self): return hash(self.key)
line:   def __bool__(self): return not (self.max == self.min == 0)
line:   def __eq__(self, other:object) -> bool:
line:   def __neg__(self): return self*-1
line:   def __add__(self, b:Union[Node,int]): return Node.sum([self, NumNode(b) if isinstance(b, int) else b])
line:   def __radd__(self, b:int): return self+b
line:   def __sub__(self, b:Union[Node,int]): return self+-b
line:   def __rsub__(self, b:int): return -self+b
line:   def __le__(self, b:Union[Node,int]): return self < (b+1)
line:   def __gt__(self, b:Union[Node,int]): return (-self) < (-b)
line:   def __ge__(self, b:Union[Node,int]): return (-self) < (-b+1)
line:   def __lt__(self, b:Union[Node,int]): return create_node(LtNode(self, b))
line:   def __mul__(self, b:Union[Node, int]):
line:   def __rmul__(self, b:int): return self*b
line:   def __lshift__(self, b:int): return self*2**b
line:   def __rfloordiv__(self, b:int): return NumNode(b) // self
line:   def __floordiv__(self, b:Union[Node,int], factoring_allowed=True):
line:   def __rmod__(self, b:int): return NumNode(b) % self
line:   def __mod__(self, b:Union[Node,int]):
line:   @staticmethod
line:   def sum(nodes:List[Node]) -> Node:
line:   @staticmethod
line:   def ands(nodes:List[Node]) -> Node:
retu:   def ands(nodes:List[Node]) -> Node:
line: class Variable(Node):
call: class Variable(Node):
line: class Variable(Node):
line:   def __new__(cls, *args):
line:   def __getnewargs__(self): return (self.expr, self.min, self.max)  # args passed to __new__ when unpickling
line:   def __init__(self, expr:str, nmin:int, nmax:sint):
line:   @property
line:   def val(self):
line:   def bind(self, val):
line:   def unbind(self) -> Tuple[Variable, int]:
line:   def vars(self): return {self}
line:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node: return var_vals.get(self, self)
retu:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node: return var_vals.get(self, self)
line: class NumNode(Node):
call: class NumNode(Node):
line: class NumNode(Node):
line:   def __init__(self, num:int):
line:   def bind(self, val):
line:   def __mul__(self, b:Union[Node,int]): return NumNode(self.b*b) if isinstance(b, int) else b*self.b
line:   def __eq__(self, other): return self.b == other
line:   def __hash__(self): return hash(self.b)  # needed with __eq__ override
line:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node: return self
retu:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node: return self
line: def create_node(ret:Node):
line: def create_lt_node(lhs:Node, b:Union[Node, int]):
line: def create_ge_node(lhs:Node, b:Union[Node, int]): return create_lt_node(-lhs, -b+1)
line: class OpNode(Node):
call: class OpNode(Node):
line: class OpNode(Node):
line:   def __init__(self, a:Node, b:Union[Node, int]):
line:   def vars(self): return self.a.vars() | (self.b.vars() if isinstance(self.b, Node) else set())
line:   def get_bounds(self) -> Tuple[int, sint]: raise NotImplementedError("must be implemented")
retu:   def get_bounds(self) -> Tuple[int, sint]: raise NotImplementedError("must be implemented")
line: class LtNode(OpNode):
call: class LtNode(OpNode):
line: class LtNode(OpNode):
line:   def get_bounds(self) -> Tuple[int, int]:
line:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node:
retu:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node:
line: class MulNode(OpNode):
call: class MulNode(OpNode):
line: class MulNode(OpNode):
line:   def __mul__(self, b: Union[Node, int]): return self.a*(self.b*b) # two muls in one mul
line:   def __floordiv__(self, b: Union[Node, int], factoring_allowed=False): # NOTE: mod negative isn't handled right
line:   def __mod__(self, b: Union[Node, int]): return Node.__mod__(self.a * (self.b%b), b)
line:   def get_bounds(self) -> Tuple[int, sint]:
line:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node:
retu:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node:
line: class DivNode(OpNode):
call: class DivNode(OpNode):
line: class DivNode(OpNode):
line:   def __floordiv__(self, b: Union[Node, int], _=False): return self.a//(self.b*b) # two divs is one div
line:   def get_bounds(self) -> Tuple[int, sint]:
line:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node: return self.a.substitute(var_vals) // self.b
retu:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node: return self.a.substitute(var_vals) // self.b
line: class ModNode(OpNode):
call: class ModNode(OpNode):
line: class ModNode(OpNode):
line:   def __mod__(self, b: Union[Node, int]):
line:   def __floordiv__(self, b: Union[Node, int], factoring_allowed=True):
line:   def get_bounds(self) -> Tuple[int, sint]:
line:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node: return self.a.substitute(var_vals) % self.b
retu:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node: return self.a.substitute(var_vals) % self.b
line: class RedNode(Node):
call: class RedNode(Node):
line: class RedNode(Node):
line:   def __init__(self, nodes:List[Node]):
line:   def vars(self) -> Set[Variable]: return set.union(*[x.vars() for x in self.nodes], set())
line:   def get_bounds(self) -> Tuple[int, sint]: raise NotImplementedError("must be implemented")
retu:   def get_bounds(self) -> Tuple[int, sint]: raise NotImplementedError("must be implemented")
line: class SumNode(RedNode):
call: class SumNode(RedNode):
line: class SumNode(RedNode):
line:   def get_bounds(self) -> Tuple[int, sint]: return sum([x.min for x in self.nodes]), sum([x.max for x in self.nodes])
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def __mul__(self, b: Union[Node, int]): return Node.sum([x*b for x in self.nodes]) # distribute mul into sum
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def __floordiv__(self, b: Union[Node, sint], factoring_allowed=True):
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def __mod__(self, b: Union[Node, int]):
line:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node:
line:   @property
line:   def flat_components(self): return [y for x in self.nodes for y in (x.flat_components if isinstance(x, SumNode) else [x])]
retu:   def flat_components(self): return [y for x in self.nodes for y in (x.flat_components if isinstance(x, SumNode) else [x])]
line: class AndNode(RedNode):
call: class AndNode(RedNode):
line: class AndNode(RedNode):
line:   def get_bounds(self) -> Tuple[int, sint]: return min([x.min for x in self.nodes]), max([x.max for x in self.nodes])
line:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node:
retu:   def substitute(self, var_vals: Mapping[Variable, Union[NumNode, Variable]]) -> Node:
line: def sym_render(a: Union[Node, int], ops=None, ctx=None) -> str: return str(a) if isinstance(a, int) else a.render(ops, ctx)
line: def sym_infer(a: Union[Node, int], var_vals: Optional[Dict[Variable, int]]) -> int:
line: sint = Union[int, Variable, MulNode, SumNode]
line: def render_mulnode(node:MulNode, ops, ctx):
line:   Variable: lambda self,ops,ctx: f"{self.expr}[{self.min}-{self.max}{'='+str(self.val) if self._val is not None else ''}]" if ctx == "DEBUG" \
line:   NumNode: lambda self,ops,ctx: f"NumNode({self.b})" if ctx == "REPR" else f"{self.b}",
line:   MulNode: render_mulnode,
line:   DivNode: lambda self,ops,ctx: f"({self.a.render(ops,ctx)}//{self.b})",
line:   ModNode: lambda self,ops,ctx: f"({self.a.render(ops,ctx)}%{self.b})",
line:   LtNode: lambda self,ops,ctx: f"({self.a.render(ops,ctx)}<{sym_render(self.b,ops,ctx)})",
line:   SumNode: lambda self,ops,ctx: f"({'+'.join(sorted([x.render(ops,ctx) for x in self.nodes]))})",
line:   AndNode: lambda self,ops,ctx: f"({' and '.join(sorted([x.render(ops,ctx) for x in self.nodes]))})",
line: render_python: Dict[Type, Callable[..., str]] = {
retu: render_python: Dict[Type, Callable[..., str]] = {
line: from tinygrad.shape.shapetracker import ShapeTracker
call: # ShapeTracker allows movement operations to a buffer that don't require a copy to be made.
line: from __future__ import annotations
line: from dataclasses import dataclass
line: from typing import Tuple, List, Optional, Dict, Set, Iterable, cast
line: from tinygrad.helpers import merge_dicts, getenv
line: from tinygrad.shape.symbolic import Variable, MulNode, Node, SumNode, NumNode, sint
line: from tinygrad.shape.view import View, strides_for_shape
call: from __future__ import annotations
line: from __future__ import annotations
line: import functools, operator, itertools, math
line: from dataclasses import dataclass
line: from typing import Tuple, List, Optional, Dict, Set, cast
line: from tinygrad.helpers import prod, all_int, argsort
line: from tinygrad.shape.symbolic import Node, NumNode, Variable, sint, sym_infer, create_lt_node, create_ge_node
line: @functools.lru_cache(maxsize=None)
line: def canonicalize_strides(shape:Tuple[sint, ...], strides:Tuple[sint, ...]) -> Tuple[sint, ...]:
line: @functools.lru_cache(maxsize=None)
line: def strides_for_shape(shape:Tuple[sint, ...]) -> Tuple[sint, ...]:
line: @functools.lru_cache(maxsize=None)
line: def _merge_dims(shape:Tuple[int, ...], strides:Tuple[int, ...], mask:Optional[Tuple[Tuple[int, int], ...]]=None) -> Tuple[Tuple[int, int, int], ...]:
line: @functools.lru_cache(maxsize=None)
line: def _reshape_mask(_mask:Optional[Tuple[Tuple[sint, sint], ...]], old_shape:Tuple[sint, ...], new_shape:Tuple[sint, ...]) \
line: def un1d(shape:Tuple[sint, ...], offs:sint) -> List[sint]:
line: @dataclass(frozen=True)
line: class View:
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   shape:Tuple[sint, ...]
line:   strides:Tuple[sint, ...]
line:   offset:sint
line:   mask:Optional[Tuple[Tuple[sint, sint], ...]]
line:   contiguous:bool
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def size(self) -> int:
line:   @staticmethod
line:   @functools.lru_cache(maxsize=None)
line:   def create(shape:Tuple[sint, ...], strides:Optional[Tuple[sint, ...]]=None, offset:sint=0, mask:Optional[Tuple[Tuple[sint, sint], ...]]=None):
line:   @functools.lru_cache(None)  # pylint: disable=method-cache-max-size-none
line:   def vars(self) -> Set[Variable]:
line:   @functools.lru_cache(None)  # pylint: disable=method-cache-max-size-none
line:   def unbind(self) -> Tuple[View, Dict[Variable, int]]:
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def __add__(self, vm1:View) -> Optional[View]:
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def invert(self, out_shape:Tuple[sint, ...]) -> Optional[View]:
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def minify(self):
line:   def __unsafe_resize(self, arg: Tuple[Tuple[sint, sint], ...], mask=None) -> View:
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def pad(self, arg: Tuple[Tuple[sint, sint], ...]) -> View:
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def shrink(self, arg: Tuple[Tuple[sint, sint], ...]) -> View:
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def expand(self, new_shape: Tuple[sint, ...]) -> View:
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def permute(self, axis: Tuple[int, ...]) -> View:
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def stride(self, mul: Tuple[int, ...]) -> View:
line:   @functools.lru_cache(maxsize=None)  # pylint: disable=method-cache-max-size-none
line:   def reshape(self, new_shape: Tuple[sint, ...]) -> Optional[View]:
line:   def expr(self, idxs:List[Node], valid:Optional[Node]=None) -> Tuple[Node, Node]:
retu:   def expr(self, idxs:List[Node], valid:Optional[Node]=None) -> Tuple[Node, Node]:
retu: class View:
line: @dataclass(frozen=True)
line: class ShapeTracker:
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   views: Tuple[View, ...]
line:   def __add__(self, st:ShapeTracker) -> ShapeTracker:
line:   def invert(self, out_shape:Tuple[sint, ...]) -> Optional[ShapeTracker]:
line:   @staticmethod
line:   def from_shape(shape:Tuple[sint, ...]): return ShapeTracker((View.create(shape),))
line:   @property
line:   def contiguous(self) -> bool: return len(self.views) == 1 and self.views[0].contiguous
line:   @property
line:   def consecutive(self) -> bool: return len(self.views) == 1 and (v:=self.views[0]).mask is None and v.strides == strides_for_shape(v.shape)
line:   @property
line:   def shape(self) -> Tuple[sint, ...]: return self.views[-1].shape
line:   @property
line:   def size(self) -> int: return self.views[-1].size()
line:   def real_size(self) -> int:
line:   def vars(self) -> Set[Variable]: return set.union(*[v.vars() for v in self.views], set())
line:   @property
line:   def var_vals(self) -> Dict[Variable, int]: return merge_dicts([dict([v.unbind()]) for v in self.vars()])
line:   def unbind(self) -> Tuple[ShapeTracker, Dict[Variable, int]]:
line:   def real_strides(self, ignore_valid=False) -> Tuple[Optional[sint], ...]:
line:   def unit_stride_axes(self, ignore_valid=False) -> List[int]: return [i for i,st in enumerate(self.real_strides(ignore_valid)) if st == 1]
line:   def expr_idxs(self, idxs:Optional[Iterable[Node]]=None) -> Tuple[Node, Node]:
line:   def axis_is_masked(self, axis:int) -> bool:
line:   def simplify(self) -> ShapeTracker:
line:   def pad(self, arg: Tuple[Tuple[sint, sint], ...]) -> ShapeTracker: return ShapeTracker(self.views[0:-1] + (self.views[-1].pad(arg), ))
line:   def shrink(self, arg: Tuple[Tuple[sint, sint], ...]) -> ShapeTracker: return ShapeTracker(self.views[0:-1] + (self.views[-1].shrink(arg), ))
line:   def expand(self, new_shape: Tuple[sint, ...]) -> ShapeTracker: return ShapeTracker(self.views[0:-1] + (self.views[-1].expand(new_shape), ))
line:   def permute(self, axis: Tuple[int, ...]) -> ShapeTracker: return ShapeTracker(self.views[0:-1] + (self.views[-1].permute(axis), ))
line:   def stride(self, mul: Tuple[int, ...]) -> ShapeTracker: return ShapeTracker(self.views[0:-1] + (self.views[-1].stride(mul), ))
line:   def reshape(self, new_shape: Tuple[sint, ...]) -> ShapeTracker:
retu:   def reshape(self, new_shape: Tuple[sint, ...]) -> ShapeTracker:
retu: class ShapeTracker:
line: class UnaryOps(Enum):
call: class UnaryOps(Enum):
line: class UnaryOps(Enum):
line:   """A -> A (elementwise)"""
line:   EXP2 = auto(); LOG2 = auto(); CAST = auto(); BITCAST = auto(); SIN = auto(); SQRT = auto(); NEG = auto(); RECIP = auto() # noqa: E702
retu:   EXP2 = auto(); LOG2 = auto(); CAST = auto(); BITCAST = auto(); SIN = auto(); SQRT = auto(); NEG = auto(); RECIP = auto() # noqa: E702
line: class BinaryOps(Enum):
call: class BinaryOps(Enum):
line: class BinaryOps(Enum):
line:   """A + A -> A (elementwise)"""
line:   ADD = auto(); MUL = auto(); IDIV = auto(); MAX = auto(); MOD = auto(); CMPLT = auto(); CMPNE = auto(); XOR = auto() # noqa: E702
line:   SHL = auto(); SHR = auto(); OR = auto(); AND = auto(); THREEFRY = auto() # noqa: E702
retu:   SHL = auto(); SHR = auto(); OR = auto(); AND = auto(); THREEFRY = auto() # noqa: E702
line: class TernaryOps(Enum):
call: class TernaryOps(Enum):
line: class TernaryOps(Enum):
line:   """A + A + A -> A (elementwise)"""
line:   WHERE = auto(); MULACC = auto() # noqa: E702
retu:   WHERE = auto(); MULACC = auto() # noqa: E702
line: class ReduceOps(Enum):
call: class ReduceOps(Enum):
line: class ReduceOps(Enum):
line:   """A -> B (reduce)"""
line:   SUM = auto(); MAX = auto(); WMMA = auto() # noqa: E702
retu:   SUM = auto(); MAX = auto(); WMMA = auto() # noqa: E702
line: class BufferOps(Enum): LOAD = auto(); CONST = auto(); STORE = auto() # noqa: E702
call: class BufferOps(Enum): LOAD = auto(); CONST = auto(); STORE = auto() # noqa: E702
line: class BufferOps(Enum): LOAD = auto(); CONST = auto(); STORE = auto() # noqa: E702
retu: class BufferOps(Enum): LOAD = auto(); CONST = auto(); STORE = auto() # noqa: E702
line: class MetaOps(Enum):
call: class MetaOps(Enum):
line: class MetaOps(Enum):
line:   EMPTY = auto(); CONST = auto(); COPY = auto(); CONTIGUOUS = auto(); CUSTOM = auto(); ASSIGN = auto(); VIEW = auto(); KERNEL = auto() # noqa: E702
retu:   EMPTY = auto(); CONST = auto(); COPY = auto(); CONTIGUOUS = auto(); CUSTOM = auto(); ASSIGN = auto(); VIEW = auto(); KERNEL = auto() # noqa: E702
line: Op = Union[UnaryOps, BinaryOps, ReduceOps, MetaOps, TernaryOps, BufferOps]
line: UNSAFE_PAD_OPS = {UnaryOps.RECIP, UnaryOps.LOG2, UnaryOps.EXP2, BinaryOps.IDIV}
line: @dataclass(frozen=True)
line: class MemBuffer:
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   idx: int
line:   dtype: DType
line:   st: ShapeTracker
retu:   st: ShapeTracker
line: @dataclass(frozen=True)
line: class ConstBuffer:
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   val: ConstType | Variable
line:   dtype: DType
line:   st: ShapeTracker
retu:   st: ShapeTracker
line: @dataclass(frozen=True)
line: class KernelInfo:
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   local_dims: int = 0           # number of local dimensions  (this is remapping RANGE to SPECIAL)
line:   upcasted: int = 0             # count that are upcasted     (this is remapping RANGE to EXPAND)
line:   dont_use_locals: bool = False # don't use local indexing
retu:   dont_use_locals: bool = False # don't use local indexing
line: @dataclass(frozen=True, eq=False)
line: class LazyOp:
call: @dataclass(frozen=True, eq=False)
line: @dataclass(frozen=True, eq=False)
line:   op: Op
line:   src: Tuple[LazyOp, ...] = ()
line:   arg: Any = None
line:   def cached_compare(self, x, context):
line:   def __eq__(self, x): return self.cached_compare(x, context={})
line:   def __repr__(self:LazyOp): return pretty_print(self, lambda x: f'LazyOp({x.op}, arg={x.arg}, src=(%s))')
line:   @functools.cached_property
line:   def dtype(self) -> DType:
line:   @functools.cached_property
line:   def full_shape(self) -> Tuple[sint, ...]:
line:   @functools.cached_property
line:   def key(self) -> bytes:
line:   @functools.cached_property
line:   def hash(self): return hash((self.op, self.src, self.arg))
line:   def __hash__(self): return self.hash
line:   @functools.cached_property
line:   def lazyops(self) -> List[LazyOp]: return dedup([self] + [item for x in self.src for item in x.lazyops])
line:   def vars(self) -> List[Variable]:
line:   def __add__(self, x:LazyOp): return LazyOp(BinaryOps.ADD, (self, x))
line:   def __sub__(self, x:LazyOp): return LazyOp(BinaryOps.ADD, (self, -x))
line:   def __mul__(self, x:LazyOp): return LazyOp(BinaryOps.MUL, (self, x))
line:   def ne(self, x:LazyOp): return LazyOp(BinaryOps.CMPNE, (self, x))
line:   def eq(self, x:LazyOp): return -self.ne(x)
line:   def __neg__(self): return LazyOp(UnaryOps.NEG, (self,))
line:   @staticmethod
line:   def const(val, dtype:DType, shape:Tuple[sint, ...]):
retu:   def const(val, dtype:DType, shape:Tuple[sint, ...]):
line: def hook_overflow(dv, fxn):
line: python_alu: Dict[Op, Callable]  = {
line:   UnaryOps.LOG2: lambda x: math.log2(x) if x > 0 else -math.inf if x == 0 else math.nan,
line: python_alu: Dict[Op, Callable]  = {
line:   UnaryOps.EXP2: hook_overflow(math.inf, lambda x: 2**x),
call: def hook_overflow(dv, fxn):
line:   def wfxn(*args):
line:   return wfxn
retu:   return wfxn
line: python_alu: Dict[Op, Callable]  = {
line:   UnaryOps.SQRT: lambda x: math.sqrt(x) if x >= 0 else math.nan,
line: python_alu: Dict[Op, Callable]  = {
line:   UnaryOps.SIN: lambda x: math.sin(x) if not math.isinf(x) else math.nan,
line: python_alu: Dict[Op, Callable]  = {
line:   UnaryOps.RECIP: lambda x: 1/x if x != 0 else math.copysign(math.inf, x),
line: python_alu: Dict[Op, Callable]  = {
line:   UnaryOps.NEG: lambda x: (not x) if isinstance(x, bool) else -x,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.SHR: operator.rshift, BinaryOps.SHL: operator.lshift,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.SHR: operator.rshift, BinaryOps.SHL: operator.lshift,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.MUL: operator.mul, BinaryOps.ADD: operator.add,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.MUL: operator.mul, BinaryOps.ADD: operator.add,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.XOR: operator.xor, BinaryOps.MAX: max, BinaryOps.CMPNE: operator.ne, BinaryOps.CMPLT: operator.lt,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.XOR: operator.xor, BinaryOps.MAX: max, BinaryOps.CMPNE: operator.ne, BinaryOps.CMPLT: operator.lt,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.XOR: operator.xor, BinaryOps.MAX: max, BinaryOps.CMPNE: operator.ne, BinaryOps.CMPLT: operator.lt,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.XOR: operator.xor, BinaryOps.MAX: max, BinaryOps.CMPNE: operator.ne, BinaryOps.CMPLT: operator.lt,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.OR: operator.or_, BinaryOps.AND: operator.and_,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.OR: operator.or_, BinaryOps.AND: operator.and_,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.MOD: lambda x,y: abs(int(x))%abs(int(y))*(1,-1)[x<0], BinaryOps.IDIV: lambda x, y: int(x/y) if y != 0 else x*math.inf,
line: python_alu: Dict[Op, Callable]  = {
line:   BinaryOps.MOD: lambda x,y: abs(int(x))%abs(int(y))*(1,-1)[x<0], BinaryOps.IDIV: lambda x, y: int(x/y) if y != 0 else x*math.inf,
line:   TernaryOps.MULACC: lambda x,y,z: (x*y)+z,
line:   TernaryOps.WHERE: lambda x,y,z: y if x else z}
line: python_alu: Dict[Op, Callable]  = {
line: def truncate_fp16(x):
line: truncate: Dict[DType, Callable] = {dtypes.bool: bool,
line:   dtypes.float16: truncate_fp16, dtypes.float32: lambda x: ctypes.c_float(x).value, dtypes.float64: lambda x: ctypes.c_double(x).value,
line:   dtypes.uint8: lambda x: ctypes.c_uint8(x).value, dtypes.uint16: lambda x: ctypes.c_uint16(x).value,
line:   dtypes.uint32: lambda x: ctypes.c_uint32(x).value, dtypes.uint64: lambda x: ctypes.c_uint64(x).value,
line:   dtypes.int8: lambda x: ctypes.c_int8(x).value, dtypes.int16: lambda x: ctypes.c_int16(x).value, dtypes.int32: lambda x: ctypes.c_int32(x).value \
line:       if isinstance(x,int) else x, dtypes.int64: lambda x: ctypes.c_int64(x).value, dtypes.bigint: lambda x: x }
line: truncate: Dict[DType, Callable] = {dtypes.bool: bool,
line: def exec_alu(op:Op, dtype:DType, operands): return truncate.get(dtype, lambda x: x)(python_alu[op](*operands))
line: def reduce_st(st:ShapeTracker, axis:Tuple[int, ...]) -> Tuple[sint, ...]: return tuple(1 if i in axis else s for i,s in enumerate(st.shape))
line: def verify_lazyop(ast:LazyOp) -> Dict[LazyOp, ShapeTracker]:
retu: def verify_lazyop(ast:LazyOp) -> Dict[LazyOp, ShapeTracker]:
line: from tinygrad.shape.symbolic import sint, Variable
line: from tinygrad.shape.shapetracker import ShapeTracker
line: from tinygrad.device import Buffer
call: from __future__ import annotations
line: from __future__ import annotations
line: import multiprocessing
line: from dataclasses import dataclass
line: from collections import defaultdict
line: from typing import List, Optional, Dict, Tuple, Any, cast, Protocol, Type
line: import importlib, inspect, functools, pathlib, os, ctypes, atexit, time, contextlib, array
line: from tinygrad.helpers import SAVE_SCHEDULE, getenv, diskcache_get, diskcache_put, DEBUG, GlobalCounters, flat_mv, from_mv, ProfileLogger, PROFILE
line: from tinygrad.dtype import DType, ImageDType
line: from tinygrad.renderer import Renderer
call: from typing import Optional, List, Tuple, Dict
line: from typing import Optional, List, Tuple, Dict
line: import functools
line: from dataclasses import dataclass
line: from tinygrad.helpers import to_function_name
line: from tinygrad.codegen.uopgraph import UOpGraph
call: from __future__ import annotations
line: from __future__ import annotations
line: from typing import Iterator, Optional, Tuple, Dict, List, Set, Union, cast, TYPE_CHECKING
line: import functools, itertools, heapq, math
line: from tinygrad.dtype import dtypes, PtrDType, ImageDType
line: from tinygrad.shape.symbolic import Variable
line: from tinygrad.ops import UnaryOps, BinaryOps, TernaryOps, ReduceOps, exec_alu
line: from tinygrad.helpers import DEBUG, getenv, flatten, dedup, TRANSCENDENTAL, prod, CI
line: from tinygrad.codegen.uops import UOp, UOps, UPat, PatternMatcher, END_FOR_UOP, type_verify
call: from __future__ import annotations
line: from __future__ import annotations
line: from typing import Optional, Tuple, Any, Set, cast, List, Union, DefaultDict, Callable, Dict
line: import functools, itertools
line: from collections import defaultdict
line: from enum import Enum, auto
line: from dataclasses import dataclass
line: from tinygrad.dtype import ConstType, dtypes, DType
line: from tinygrad.shape.symbolic import sint, Variable
line: from tinygrad.ops import UnaryOps, BinaryOps, TernaryOps, exec_alu
line: from tinygrad.helpers import prod, pretty_print
line: class UOps(Enum):
call: class UOps(Enum):
line: class UOps(Enum):
line:   SINK = auto(); VAR = auto(); EXPAND = auto(); CONTRACT = auto() # noqa: E702
line:   DEFINE_GLOBAL = auto(); DEFINE_VAR = auto(); DEFINE_LOCAL = auto(); DEFINE_ACC = auto() # noqa: E702
line:   CONST = auto(); SPECIAL = auto() # noqa: E702
line:   NOOP = auto(); UNMUL = auto(); GEP = auto() # noqa: E702
line:   CAST = auto(); BITCAST = auto(); VECTORIZE = auto() # noqa: E702
line:   ALU = auto(); REDUCE = auto(); WMMA = auto() # noqa: E702
line:   LOAD = auto(); STORE = auto(); PHI = auto() # noqa: E702
line:   BARRIER = auto(); IF = auto(); RANGE = auto() # noqa: E702
line:   ENDRANGE = auto(); ENDIF = auto() # noqa: E702
retu:   ENDRANGE = auto(); ENDIF = auto() # noqa: E702
line: END_FOR_UOP = {UOps.IF:(UOps.STORE, UOps.ENDIF), UOps.RANGE:(UOps.PHI, UOps.ENDRANGE)}
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: @dataclass(frozen=True, eq=False)
line: class UOp:
call: @dataclass(frozen=True, eq=False)
line: @dataclass(frozen=True, eq=False)
line:   op: UOps
line:   dtype: Optional[DType] = None
line:   src: Tuple[UOp, ...] = tuple()
line:   arg: Any = None
line:   def commutative(self) -> bool:
line:   @functools.cached_property
line:   def cmp_tuple(self):
line:   def __lt__(self, x:UOp): return self.cmp_tuple < x.cmp_tuple
line:   def __repr__(self): return pretty_print(self, lambda x: f"UOp({x.op}, {x.dtype}, arg={x.arg}, src=(%s))")
line:   def cast(self, dtype=None): return UOp(UOps.CAST, dtype, (self,))
line:   def bitcast(self, dtype=None): return UOp(UOps.BITCAST, dtype, (self,))
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __radd__(self, x): return UOp.alu(BinaryOps.ADD, ufix(self.dtype, x), self)
line:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __rmul__(self, x): return UOp.alu(BinaryOps.MUL, ufix(self.dtype, x), self)
line:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
line:   def __xor__(self, x): return UOp.alu(BinaryOps.XOR, self, ufix(self.dtype, x))
line:   def __and__(self, x): return UOp.alu(BinaryOps.AND, self, ufix(self.dtype, x))
line:   def __or__(self, x): return UOp.alu(BinaryOps.OR, self, ufix(self.dtype, x))
line:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
line:   def eq(self, x): return -self.ne(x)
line:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
line:   def ge(self, x): return -self.lt(x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def min(self, x): return -UOp.alu(BinaryOps.MAX, -self, -x)
line:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line:   def recip(self): return UOp.alu(UnaryOps.RECIP, self)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   @staticmethod
line:   @functools.lru_cache(maxsize=None)
line:   def _const(dtype:Optional[DType], b:ConstType|Variable):
line:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
line:   @staticmethod
line:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
line:   @staticmethod
line:   def store(*src:UOp, **kwargs): return UOp(UOps.STORE, None, tuple(src)+tuple(kwargs.values()))
line:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
line:   @functools.cached_property
line:   def parents(self) -> Set[UOp]: return set.union(set(self.src), *[x.parents for x in self.src])
line:   @property  # parents with self
line:   def sparents(self) -> Set[UOp]: return set([self]).union(self.parents)
line:   def vars(self) -> Set[UOp]: return set([x for x in set.union(set([self]), self.parents) if x.op is UOps.DEFINE_VAR])
line:   def divides(self, v):
retu:   def divides(self, v):
line: class UPat:
call: class UPat:
line: class UPat:
line:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:                name:Optional[str]=None, dtype:Optional[Union[DType, Set[DType]]]=None, allow_any_len:bool=False):
line:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:   @staticmethod
line:   def compile(u: UOp, name:Optional[str]=None) -> UPat:
line:   def __repr__(self):
retu:   def __repr__(self):
line: def _match(uop:UOp, pat:UPat, store:Dict[str, UOp]) -> List[Dict[str, UOp]]:
line: class PatternMatcher:
call: class PatternMatcher:
line: class PatternMatcher:
line:   def __init__(self, patterns:List[Tuple[Union[UPat, UOp], Callable]]):
line:   @functools.lru_cache(None)  # pylint: disable=method-cache-max-size-none
line:   def __add__(self, more:PatternMatcher): return PatternMatcher(self.patterns+more.patterns)
line:   def rewrite(self, uop:UOp) -> Optional[UOp]:
retu:   def rewrite(self, uop:UOp) -> Optional[UOp]:
line: def type_verify(uops):
line: def uop_alu_resolve(u:UOp) -> sint:
line: def flops_mem(uops:List[UOp], ignore_indexing=False) -> Tuple[sint, sint]:
retu: def flops_mem(uops:List[UOp], ignore_indexing=False) -> Tuple[sint, sint]:
line: from tinygrad.codegen.transcendental import xexp2, xlog2, xsin, TRANSCENDENTAL_SUPPORTED_DTYPES
call: import math, functools
line: import math, functools
line: from typing import Tuple, List
line: from tinygrad.dtype import dtypes, DType
line: from tinygrad.codegen.uops import UOp
line: TRANSCENDENTAL_SUPPORTED_DTYPES = {dtypes.float16, dtypes.float32, dtypes.float64}
line: def _lazy_map_numbers(x:UOp, inf:UOp, _inf:UOp, nan:UOp, ratio:UOp):
line: def dfadd2_f2_f2_f2(xx:UOp, xy:UOp, yx:UOp, yy:UOp) -> Tuple[UOp, UOp]: return xx + yx, xy + yy
line: def dfmul2_f2_f2_f2(xx:UOp, xy:UOp, yx:UOp, yy:UOp) -> Tuple[UOp, UOp]: return xx * yx, xx * yy + xy * yx
line: def dfdiv2_f2_f2_f2(nx:UOp, ny:UOp, dx:UOp, dy:UOp) -> Tuple[UOp, UOp]:
line: def significand_bits(d:DType) -> int: return {dtypes.float64: 52, dtypes.float32: 23, dtypes.float16: 10}[d]
line: def exponent_bias(d:DType) -> int: return {dtypes.float64: 1022, dtypes.float32: 126, dtypes.float16: 14}[d]
line: def exponent_mask(d:DType) -> int: return {dtypes.float64: 0x7FF, dtypes.float32: 0xFF, dtypes.float16: 0x1F}[d]
line: def float_to_bits(d:UOp) -> UOp:
line: def bits_to_float(d:UOp, float_dtype:DType) -> UOp:
line: def shr(x:UOp, y:int) -> UOp: return x // (2**y)
line: def shl(x:UOp, y:int) -> UOp: return x * (2**y)
line: def rintk(d:UOp) -> UOp:
line: def pow2if(q:UOp, float_dtype:DType):
line: def ilogb2k(d:UOp) -> UOp:
line: def ldexp3k(d:UOp, e:UOp) -> UOp:
line: def ldexp2k(d:UOp, e:UOp) -> UOp:
line: def frexp(v:UOp) -> Tuple[UOp, UOp]:
line: def mla(x:UOp, y:UOp, z:UOp) -> UOp: return x * y + z
line: def polyN(u:UOp, s:UOp, coeffs:List[float]) -> UOp: return functools.reduce(lambda u,c: mla(u, s, u.const(c)), coeffs, u)
line: def payne_hanek_reduction(d:UOp) -> Tuple[UOp, UOp]:
line: def cody_waite_reduction(d:UOp) -> Tuple[UOp, UOp]:
line: def trig_poly(d:UOp, coeff32, coeff64):
line: def sin_poly(d:UOp) -> UOp: return trig_poly(d, [2.6083159809786593541503e-06, -0.0001981069071916863322258, 0.00833307858556509017944336, -0.166666597127914428710938], [-7.97255955009037868891952e-18, 2.81009972710863200091251e-15, -7.64712219118158833288484e-13, 1.60590430605664501629054e-10, -2.50521083763502045810755e-08, 2.75573192239198747630416e-06, -0.000198412698412696162806809, 0.00833333333333332974823815, -0.166666666666666657414808]) # noqa: E501
line: def sin_poly_small(d:UOp, q:UOp) -> UOp:
line: def sin_poly_large(d:UOp, q:UOp) -> UOp:
line: def xsin(d:UOp, fast:bool=False, switch_over:float=30.0) -> UOp:
line: def xexp2(x:UOp) -> UOp:
line: def xlog2(d:UOp) -> UOp:
retu: def xlog2(d:UOp) -> UOp:
line: if TYPE_CHECKING:
line: def image_contract_load(buf, idx, idy, id4, ls_allow_any_len):
line: def image_contract_store(buf, ex, idx, idy, ls_allow_any_len, var):
line: def float4_expand_load(load, buf, ex, idx=UOp.const(dtypes.int, 0), idx2=None):
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
call:   @staticmethod
line:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
call:   @staticmethod # static methds on top, or bool in the type info will refer to dtypes.bool
line:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
retu:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line: def float4_contract_store(buf, ex, var, store_allow_any_len, idx=UOp.const(dtypes.int, 0), idx2=None, idx3=None):
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line: float4_folding = PatternMatcher([
line:   (UOp(UOps.STORE, src=(UOp.var("buf"), UOp.var("idx")+
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
line:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
line:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
call:   @staticmethod
line:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
call:   @staticmethod # static methds on top, or bool in the type info will refer to dtypes.bool
line:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
retu:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
line:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
call:   @staticmethod
line:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
call:   @staticmethod # static methds on top, or bool in the type info will refer to dtypes.bool
line:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
retu:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
line:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
call:   @staticmethod
line:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
call:   @staticmethod # static methds on top, or bool in the type info will refer to dtypes.bool
line:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
retu:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
line:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
retu:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   (UOp(UOps.STORE, src=(UOp.var("buf"), UOp.var("idx")+
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"), UOp.var("idx")+
line:     (UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex")+UOp.var("idx2")), UOp.var("var"))).name("store"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:     lambda buf, store, idx, idx2, ex, var: UOp(UOps.STORE, store.dtype, (buf, idx+idx2+ex, var), store.arg)),
line:   (UOp(UOps.STORE, src=(UOp.var("buf"), UOp.var("idx")+
line:   (UOp(UOps.LOAD, src=(UOp.var("buf"), UOp(UOps.EXPAND).name("ex")+UOp.var("idx")+UOp.var("idx2"))).name("load"), float4_expand_load),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.LOAD, src=(UOp.var("buf"), UOp(UOps.EXPAND).name("ex")+UOp.var("idx"))).name("load"), float4_expand_load),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.LOAD, src=(UOp.var("buf"), UOp(UOps.EXPAND).name("ex"))).name("load"), float4_expand_load),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:     UOp(UOps.EXPAND).name("ex")+UOp.var("idx")+UOp.var("idx2")+UOp.var("idx3"), UOp.var("var"))).name("store_allow_any_len"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
line:     UOp(UOps.EXPAND).name("ex")+UOp.var("idx")+UOp.var("idx2")+UOp.var("idx3"), UOp.var("var"))).name("store_allow_any_len"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:     float4_contract_store),
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:     UOp(UOps.EXPAND).name("ex")+UOp.var("idx")+UOp.var("idx2"), UOp.var("var"))).name("store_allow_any_len"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
line:     UOp(UOps.EXPAND).name("ex")+UOp.var("idx")+UOp.var("idx2"), UOp.var("var"))).name("store_allow_any_len"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:     float4_contract_store),
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:     UOp(UOps.EXPAND).name("ex")+UOp.var("idx"), UOp.var("var"))).name("store_allow_any_len"), float4_contract_store),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
line:     UOp(UOps.EXPAND).name("ex")+UOp.var("idx"), UOp.var("var"))).name("store_allow_any_len"), float4_contract_store),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:     UOp(UOps.EXPAND).name("ex"), UOp.var("var"))).name("store_allow_any_len"), float4_contract_store),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
line:     UOp(UOps.EXPAND).name("ex"), UOp.var("var"))).name("store_allow_any_len"), float4_contract_store),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"),
line:   (UOp(UOps.LOAD, src=(UOp.var("buf"), UOp(UOps.VECTORIZE, dtypes.int.vec(3), (UOp.var('idx'), UOp.var('idy'),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def vec(self, sz:int):
line:     assert sz > 1 and self.count == 1, f"can't vectorize {self} with size {sz}"
line:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
retu:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:      UOp.var('id4'))))).name("ls_allow_any_len"), image_contract_load),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:   (UOp(UOps.LOAD, src=(UOp.var("buf"), UOp(UOps.VECTORIZE, dtypes.int.vec(3), (UOp.var('idx'), UOp.var('idy'),
line:      UOp.var('id4'))))).name("ls_allow_any_len"), image_contract_load),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.LOAD, src=(UOp.var("buf"), UOp(UOps.VECTORIZE, dtypes.int.vec(3), (UOp.var('idx'), UOp.var('idy'),
line:   (UOp(UOps.STORE, src=(UOp.var("buf"), UOp(UOps.VECTORIZE, dtypes.int.vec(3), (UOp.var('idx'), UOp.var('idy'),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def vec(self, sz:int):
line:     assert sz > 1 and self.count == 1, f"can't vectorize {self} with size {sz}"
line:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
retu:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
line:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
line:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
line:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
line:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
line:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
retu:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"), UOp(UOps.VECTORIZE, dtypes.int.vec(3), (UOp.var('idx'), UOp.var('idy'),
line:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:   (UOp(UOps.STORE, src=(UOp.var("buf"), UOp(UOps.VECTORIZE, dtypes.int.vec(3), (UOp.var('idx'), UOp.var('idy'),
line:      UOp(UOps.EXPAND, src=tuple(UOp.const(dtypes.int, i) for i in range(4))).name("ex"))), UOp.var("var"))).name("ls_allow_any_len"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:      image_contract_store),
line:   (UOp(UOps.STORE, src=(UOp.var("buf"), UOp(UOps.VECTORIZE, dtypes.int.vec(3), (UOp.var('idx'), UOp.var('idy'),
line: float4_folding = PatternMatcher([
call:   def __init__(self, patterns:List[Tuple[Union[UPat, UOp], Callable]]):
line:     self.patterns = patterns
line:     self.pdict: DefaultDict[Tuple[UOps, Any], List[Tuple[UPat, Callable]]] = defaultdict(list)
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
retu:     for p,fxn in self.patterns:
line: transcendental_folding = PatternMatcher([
line:   (UPat(UOps.ALU, dtype=TRANSCENDENTAL_SUPPORTED_DTYPES, src=(UPat(name="x"),), arg=UnaryOps.EXP2), xexp2),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:   (UPat(UOps.ALU, dtype=TRANSCENDENTAL_SUPPORTED_DTYPES, src=(UPat(name="d"),), arg=UnaryOps.LOG2), xlog2),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:   (UPat(UOps.ALU, dtype=TRANSCENDENTAL_SUPPORTED_DTYPES, src=(UPat(name="d"),), arg=UnaryOps.SIN), xsin),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line: transcendental_folding = PatternMatcher([
call:   def __init__(self, patterns:List[Tuple[Union[UPat, UOp], Callable]]):
line:     self.patterns = patterns
line:     self.pdict: DefaultDict[Tuple[UOps, Any], List[Tuple[UPat, Callable]]] = defaultdict(list)
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
retu:     for p,fxn in self.patterns:
line: def threefry2x32(x: UOp, seed: UOp):
line: def reduce_before_expand(reduce_allow_any_len, expand, x):
line: def sum_collapse(phi_input, loop, val1, val2):
line: def loop_collapse(loop_start, loop_end, compval, idx, mval, multconst, rng):
line: constant_folder = PatternMatcher([
line:   (UPat(UOps.CONTRACT, name="con", src=(UPat(UOps.ALU, name="alu"),)),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:    lambda con, alu: UOp(alu.op, con.dtype, tuple(UOp(UOps.CONTRACT, x.dtype.vec(con.dtype.count), (x,), con.arg) for x in alu.src), alu.arg)),
line:   (UPat(UOps.CONTRACT, name="con", src=(UPat(UOps.ALU, name="alu"),)),
line: constant_folder = PatternMatcher([
line:   (UPat(UOps.CONTRACT, name="con", src=(UPat(UOps.REDUCE, dtype={dtypes.half, dtypes.bfloat16, dtypes.float}, name="red"),)),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:    lambda con, red: UOp(UOps.REDUCE, con.dtype, (UOp(UOps.CONTRACT, con.dtype, red.src[0:1], con.arg),)+red.src[1:], red.arg)),
line:   (UPat(UOps.CONTRACT, name="con", src=(UPat(UOps.REDUCE, dtype={dtypes.half, dtypes.bfloat16, dtypes.float}, name="red"),)),
line: constant_folder = PatternMatcher([
line:   (UPat(UOps.CONTRACT, name="con", src=(UPat(UOps.CAST, dtype={dtypes.half, dtypes.bfloat16, dtypes.float}, src=(UPat(name="casted"),)),)),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:    lambda con, casted: UOp(UOps.CAST, con.dtype, (UOp(UOps.CONTRACT, casted.dtype.vec(con.dtype.count), (casted,), con.arg),))),
line:   (UPat(UOps.CONTRACT, name="con", src=(UPat(UOps.CAST, dtype={dtypes.half, dtypes.bfloat16, dtypes.float}, src=(UPat(name="casted"),)),)),
line: constant_folder = PatternMatcher([
line:   (UPat({UOps.CONST, UOps.ALU, UOps.SPECIAL, UOps.RANGE, UOps.EXPAND}, dtype=dtypes.bigint, name="x"),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:    lambda x: UOp(x.op, dtypes.int32, x.src, x.arg)),
line:   (UPat({UOps.CONST, UOps.ALU, UOps.SPECIAL, UOps.RANGE, UOps.EXPAND}, dtype=dtypes.bigint, name="x"),
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.GEP, src=(UOp(UOps.VECTORIZE).name("cast"),)).name("gep"), lambda gep, cast: cast.src[gep.arg]),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line: constant_folder = PatternMatcher([
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   def vec(self, sz:int):
line:     assert sz > 1 and self.count == 1, f"can't vectorize {self} with size {sz}"
line:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
retu:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   def vec(self, sz:int):
line:     assert sz > 1 and self.count == 1, f"can't vectorize {self} with size {sz}"
line:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
retu:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   def vec(self, sz:int):
line:     assert sz > 1 and self.count == 1, f"can't vectorize {self} with size {sz}"
line:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
retu:     return DType(self.priority, self.itemsize*sz, f"{INVERSE_DTYPES_DICT[self.name]}{sz}", None, sz)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
call:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:       for j in range(i))), lambda x: x) for i in [2, 4, 8]],
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
retu:   *[(UOp(UOps.VECTORIZE, dtypes.float.vec(i), tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=j)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.WMMA, src=(UOp.const(None, 0.0), UOp.var(), UOp.var('acc'))), lambda acc: acc),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.WMMA, src=(UOp.var(), UOp.const(None, 0.0), UOp.var('acc'))), lambda acc: acc),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:    .name("reduce_allow_any_len"), reduce_before_expand),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(2))).name("expand"),))
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
retu:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:    .name("reduce_allow_any_len"), reduce_before_expand),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.REDUCE, src=(UOp(UOps.EXPAND, src=tuple(UOp(UOps.GEP, dtypes.float, src=(UOp.var('x'),), arg=i) for i in range(8))).name("expand"),))
line: constant_folder = PatternMatcher([
line:   (UOp.var("add") + UOp(UOps.WMMA).name("wmma"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:     lambda add, wmma: UOp(wmma.op, wmma.dtype, (wmma.src[0], wmma.src[1], wmma.src[2]+add), wmma.arg)),
line:   (UOp.var("add") + UOp(UOps.WMMA).name("wmma"),
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.ALU, dtype=dtypes.uint64, src=(UOp.var("x"), UOp.var("seed")), arg=BinaryOps.THREEFRY), threefry2x32),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(BinaryOps.MUL,
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:     UOp.cvar("mval"), UOp(UOps.RANGE, src=(UOp.var("loop_start"), UOp.var("loop_end"))).name("rng"))),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(BinaryOps.MUL,
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
line:     UOp.cvar("compval")), UOp.cvar("multconst"), UOp.const(None,0)), loop_collapse),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(BinaryOps.MUL,
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
line:     UOp.cvar("compval")), UOp.cvar("multconst"), UOp.const(None,0)), loop_collapse),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(BinaryOps.MUL,
call:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line:     UOp.cvar("compval")), UOp.cvar("multconst"), UOp.const(None,0)), loop_collapse),
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(BinaryOps.MUL,
line: constant_folder = PatternMatcher([
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(UnaryOps.NEG,
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:     UOp(UOps.RANGE, src=(UOp.var("loop_start"), UOp.var("loop_end"))).name("rng"))),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(UnaryOps.NEG,
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
line:     UOp.cvar("compval")), UOp.cvar("multconst"), UOp.const(None, 0)),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(UnaryOps.NEG,
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
line:     UOp.cvar("compval")), UOp.cvar("multconst"), UOp.const(None, 0)),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(UnaryOps.NEG,
call:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line:     lambda **kwargs: loop_collapse(mval=UOp.const(dtypes.int, -1), **kwargs)),
line:   (UOp.where(UOp.alu(BinaryOps.CMPLT, UOp.alu(BinaryOps.ADD, UOp.var("idx"), UOp.alu(UnaryOps.NEG,
line: constant_folder = PatternMatcher([
line:   (UPat(UOps.PHI, src=(UPat(UOps.DEFINE_ACC, name="phi_input", src=[UPat(UOps.CONST), UPat(UOps.RANGE, name="loop")]),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:                        UPat(UOps.ALU, BinaryOps.ADD, src=(UPat(name="val1"), UPat(name="val2"))))), sum_collapse),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:   (UPat(UOps.PHI, src=(UPat(UOps.DEFINE_ACC, name="phi_input", src=[UPat(UOps.CONST), UPat(UOps.RANGE, name="loop")]),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:                        UPat(UOps.ALU, BinaryOps.ADD, src=(UPat(name="val1"), UPat(name="val2"))))), sum_collapse),
line:   (UPat(UOps.PHI, src=(UPat(UOps.DEFINE_ACC, name="phi_input", src=[UPat(UOps.CONST), UPat(UOps.RANGE, name="loop")]),
line: constant_folder = PatternMatcher([
line:   (UPat(UOps.PHI, src=(UPat(UOps.GEP, name="phi_input", src=(UPat(UOps.DEFINE_ACC, src=[UPat(UOps.CONST), UPat(UOps.RANGE, name="loop")]),)),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:                        UPat(UOps.ALU, BinaryOps.ADD, src=(UPat(name="val1"), UPat(name="val2"))))), sum_collapse),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:   (UPat(UOps.PHI, src=(UPat(UOps.GEP, name="phi_input", src=(UPat(UOps.DEFINE_ACC, src=[UPat(UOps.CONST), UPat(UOps.RANGE, name="loop")]),)),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:                        UPat(UOps.ALU, BinaryOps.ADD, src=(UPat(name="val1"), UPat(name="val2"))))), sum_collapse),
line:   (UPat(UOps.PHI, src=(UPat(UOps.GEP, name="phi_input", src=(UPat(UOps.DEFINE_ACC, src=[UPat(UOps.CONST), UPat(UOps.RANGE, name="loop")]),)),
line: constant_folder = PatternMatcher([
line:   (UOp.cvar('c1') * UOp(UOps.UNMUL, src=(UOp.cvar('c2'), UOp.var('v'))), lambda c1,c2,v: v if c1.arg == c2.arg else None),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.cvar('c1') * (UOp.var('add') + UOp(UOps.UNMUL, src=(UOp.cvar('c2'), UOp.var('v')))),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:     lambda c1, add, c2, v: (add*c1+v) if c1.arg == c2.arg else None),
line:   (UOp.cvar('c1') * (UOp.var('add') + UOp(UOps.UNMUL, src=(UOp.cvar('c2'), UOp.var('v')))),
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.UNMUL, src=(UOp.const(None, 0).name('zero'), UOp.var())), lambda zero: zero),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.UNMUL).name('unmul').cast().name('root'), lambda root,unmul: UOp(UOps.UNMUL, root.dtype, (unmul.src[0].cast(root.dtype), unmul.src[1]))),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def cast(self, dtype=None): return UOp(UOps.CAST, dtype, (self,))
line:   def cast(self, dtype=None): return UOp(UOps.CAST, dtype, (self,))
retu:   def cast(self, dtype=None): return UOp(UOps.CAST, dtype, (self,))
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp.var('idx').eq(UOp(UOps.RANGE).name("rng")).cast()*
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def eq(self, x): return -self.ne(x)
line:   def eq(self, x): return -self.ne(x)
call:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
line:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
retu:   def eq(self, x): return -self.ne(x)
call:   def cast(self, dtype=None): return UOp(UOps.CAST, dtype, (self,))
line:   def cast(self, dtype=None): return UOp(UOps.CAST, dtype, (self,))
retu:   def cast(self, dtype=None): return UOp(UOps.CAST, dtype, (self,))
line:     UOp(UOps.LOAD, src=(UOp.var("buf"), UOp.var('add')+UOp.var('mul')*UOp(UOps.RANGE).name("rng"))).name("ld"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp.var('idx').eq(UOp(UOps.RANGE).name("rng")).cast()*
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:     lambda idx,rng,buf,add,mul,ld: UOp(UOps.UNMUL, ld.dtype, (UOp(ld.op, ld.dtype, (buf, add+mul*idx)), rng.src[1]-rng.src[0]))),
line:   (UOp.var('idx').eq(UOp(UOps.RANGE).name("rng")).cast()*
line: constant_folder = PatternMatcher([
line:   (UOp.var('idx').eq(UOp(UOps.RANGE).name("rng")).where(
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def eq(self, x): return -self.ne(x)
line:   def eq(self, x): return -self.ne(x)
call:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
line:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
retu:   def eq(self, x): return -self.ne(x)
line:     UOp(UOps.LOAD, src=(UOp.var("buf"), UOp.var('add')+UOp.var('mul')*UOp(UOps.RANGE).name("rng"))).name("ld"), UOp.const(None, 0.0)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   (UOp.var('idx').eq(UOp(UOps.RANGE).name("rng")).where(
call:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line:     lambda idx,rng,buf,add,mul,ld: UOp(UOps.UNMUL, ld.dtype, (UOp(ld.op, ld.dtype, (buf, add+mul*idx)), rng.src[1]-rng.src[0]))),
line:   (UOp.var('idx').eq(UOp(UOps.RANGE).name("rng")).where(
line: constant_folder = PatternMatcher([
line:   (UOp.cvar("c1") - (UOp.var("x") + UOp.cvar("c2")), lambda c1, c2, x: (c1-c2)-x),  # c1 - (x + c2) -> (c1-c2) - x
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
line:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.max(UOp.cvar('c'), UOp(UOps.SPECIAL).name('s')), lambda c,s: c if (s.arg[2]-1) <= c.arg else None),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line: constant_folder = PatternMatcher([
line:   (UOp.max(UOp.cvar('c'), UOp(UOps.SPECIAL).name('s')+UOp.cvar('c2')), lambda c,s,c2: (s+c2) if 0 >= c.arg else None),  # TODO: generic
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line: constant_folder = PatternMatcher([
line:   (UOp.max(UOp.cvar('c'), -(UOp(UOps.SPECIAL).name('s')+UOp.cvar('c2'))), lambda c,s,c2: -(s+c2) if -(s.arg[2]-1+c2.arg) >= c.arg else None),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line: constant_folder = PatternMatcher([
line:   (UOp.max(UOp.cvar('c'), UOp(UOps.RANGE).name('s')), lambda c,s: s if s.src[0].arg >= c.arg else None),  # TODO: generic
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line: constant_folder = PatternMatcher([
line:   (UOp.max(UOp.cvar('c'), UOp(UOps.RANGE).name('s')+UOp.cvar('c2')), lambda c,s,c2: (s+c2) if s.src[0].arg >= c.arg else None),  # TODO: generic
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line: constant_folder = PatternMatcher([
line:   (UOp.max(UOp.cvar('c'), -(UOp(UOps.RANGE).name('s'))), lambda c,s: -s if -(s.src[1].arg-1) >= c.arg else None),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line: constant_folder = PatternMatcher([
line:   (UOp.max(UOp.cvar('c'), -(UOp(UOps.RANGE).name('s')+UOp.cvar('c2'))), lambda c,s,c2: -(s+c2) if -(s.src[1].arg-1+c2.arg) >= c.arg else None),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.GEP, src=(UOp.cvar("c"),)).name("root"), lambda root, c: UOp.const(root.dtype, c.arg)),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line: constant_folder = PatternMatcher([
line:   (UPat(UOps.CAST, name="root", src=UPat(UOps.CONST, name="c")), lambda root, c: UOp.const(root.dtype, c.arg)),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:       self.src = [itertools.repeat(src)]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line: constant_folder = PatternMatcher([
line:   (UPat(UOps.VECTORIZE, name="root", src=UPat(UOps.CONST, name="c")), lambda root, c: UOp.const(root.dtype, c.arg)),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:       self.src = [itertools.repeat(src)]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.PHI, src=(UOp(UOps.DEFINE_ACC).name("acc"), UOp.var("acc"))), lambda acc: UOp.cast(acc.src[0], acc.dtype)),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.PHI, src=(UOp(UOps.DEFINE_ACC, src=(UOp.cvar(),)), UOp.var("x"))), lambda x: x),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.PHI, src=(UOp.cvar(), UOp.var("x"))), lambda x: x),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.DEFINE_ACC, src=(UOp.cvar(),)).name("root"), lambda root: UOp.cast(root.src[0], root.dtype)),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.GEP, src=(UOp.cvar("x"),)).name("root"), lambda root,x: UOp.const(root.dtype, x.arg)),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp.max(UOp.var('x'), UOp.const(dtypes.int, -2147483648)), lambda x: x),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
call:   @staticmethod
line:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
call:   @staticmethod # static methds on top, or bool in the type info will refer to dtypes.bool
line:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
retu:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line: constant_folder = PatternMatcher([
line:   (UOp.var().lt(UOp.const(dtypes.bool, False)), lambda: UOp.const(dtypes.bool, False)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
call:   @staticmethod
line:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
call:   @staticmethod # static methds on top, or bool in the type info will refer to dtypes.bool
line:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
call:   @staticmethod
line:   def is_unsigned(x: DType) -> bool: return x.scalar() in (dtypes.uint8, dtypes.uint16, dtypes.uint32, dtypes.uint64)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def is_unsigned(x: DType) -> bool: return x.scalar() in (dtypes.uint8, dtypes.uint16, dtypes.uint32, dtypes.uint64)
retu:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
call:   @staticmethod
line:   def is_float(x: DType) -> bool: return x.scalar() in (dtypes.float16, dtypes.bfloat16, dtypes.float32, dtypes.float64)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def is_float(x: DType) -> bool: return x.scalar() in (dtypes.float16, dtypes.bfloat16, dtypes.float32, dtypes.float64)
retu:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
line:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.const(dtypes.bool, True).lt(UOp.var()), lambda: UOp.const(dtypes.bool, False)),
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
call:   @staticmethod
line:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
call:   @staticmethod # static methds on top, or bool in the type info will refer to dtypes.bool
line:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
call:   @staticmethod
line:   def is_unsigned(x: DType) -> bool: return x.scalar() in (dtypes.uint8, dtypes.uint16, dtypes.uint32, dtypes.uint64)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def is_unsigned(x: DType) -> bool: return x.scalar() in (dtypes.uint8, dtypes.uint16, dtypes.uint32, dtypes.uint64)
retu:   def is_int(x: DType) -> bool: return x.scalar() in (dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.bigint) or dtypes.is_unsigned(x)
call:   @staticmethod
line:   def is_float(x: DType) -> bool: return x.scalar() in (dtypes.float16, dtypes.bfloat16, dtypes.float32, dtypes.float64)
call:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
line:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def scalar(self): return DTYPES_DICT[self.name[:-len(str(self.count))]] if self.count > 1 else self
retu:   def is_float(x: DType) -> bool: return x.scalar() in (dtypes.float16, dtypes.bfloat16, dtypes.float32, dtypes.float64)
retu:   def as_const(val: ConstType, dtype:DType): return int(val) if dtypes.is_int(dtype) else float(val) if dtypes.is_float(dtype) else bool(val)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
line:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var().where(UOp.var("val"), UOp.var("val")), lambda val: val),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line: constant_folder = PatternMatcher([
line:   (UOp.cvar('gate').where(UOp.var('c0'), UOp.var('c1')), lambda gate, c0, c1: c0 if gate.arg else c1),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def where(self, x, y): return UOp.alu(TernaryOps.WHERE, self, x, y)
line: constant_folder = PatternMatcher([
line:   (UPat(UOps.ALU, name="root", src=UPat(UOps.CONST)), lambda root: UOp.const(root.dtype, exec_alu(root.arg, root.dtype, [x.arg for x in root.src]))),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:       self.src = [itertools.repeat(src)]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line: constant_folder = PatternMatcher([
line:   (-(-UOp.var('x')), lambda x: x),    # -(-x) -> x
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') + 0, lambda x: x),    # x+0 -> x
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') * 1, lambda x: x),    # x*1 -> x
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') * -1, lambda x: -x),  # x*-1 -> -x
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:     if isinstance(b, Variable): return UOp(UOps.DEFINE_VAR, dtype, (), b)
line:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:     return UOp(UOps.CONST, dtype, arg=dtypes.as_const(b, dtype) if dtype is not None else b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') // UOp.var('x'), lambda x: UOp.const(x.dtype, 1)), # x//x -> 1
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') // 1, lambda x: x),   # x//1 -> x
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') // -1, lambda x: -x), # x//-1 -> -x
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') / UOp.var('x'), lambda x: UOp.const(x.dtype, 1)), # x/x -> 1
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') / UOp.cvar('c'), lambda x,c: x*exec_alu(UnaryOps.RECIP, c.dtype, [c.arg])),    # x/c -> x*(1/c)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line: constant_folder = PatternMatcher([
line:   (UOp.var('x', dtype=dtypes.bool).max(UOp.const(dtypes.bool, False)), lambda x: x),  # max(x, False) -> x
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def max(self, x): return UOp.alu(BinaryOps.MAX, self, x)
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') * 0, lambda x: UOp.const(x.dtype, float('nan') if isinstance(x.arg, float) and (math.isnan(x.arg) or math.isinf(x.arg)) else 0)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var('x') - UOp.var('x'), lambda x: UOp.const(x.dtype, 0)),   # x-x -> 0
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
line:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.store(UOp.var("buf"), UOp.var("idx"), UOp.load(UOp.var("buf"), UOp.var("idx"))), lambda buf,idx:UOp(UOps.NOOP)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
retu:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
call:   @staticmethod
line:   def store(*src:UOp, **kwargs): return UOp(UOps.STORE, None, tuple(src)+tuple(kwargs.values()))
retu:   def store(*src:UOp, **kwargs): return UOp(UOps.STORE, None, tuple(src)+tuple(kwargs.values()))
line: constant_folder = PatternMatcher([
line:   ((UOp.var('x') + UOp.cvar('c1')) + UOp.cvar('c2'), lambda x,c1,c2: x+UOp.const(x.dtype, exec_alu(BinaryOps.ADD, x.dtype, [c1.arg, c2.arg]))),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   ((UOp.var('x') - UOp.cvar('c1')) + UOp.cvar('c2'), lambda x,c1,c2: x+UOp.const(x.dtype, exec_alu(BinaryOps.ADD, x.dtype, [c2.arg, -c1.arg]))),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
line:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __sub__(self, x): return UOp.alu(BinaryOps.ADD, self, -ufix(self.dtype, x))
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   ((UOp.cvar('c')*UOp.var('x')) % UOp.cvar('c'), lambda x,c: x.const(0)),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
line:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (((UOp.cvar('c')*UOp.var('x'))+UOp.var('x2')) % UOp.cvar('c'), lambda x,c,x2: x2%c),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
line:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   ((UOp.var("x") * UOp.cvar("c1")) * UOp.cvar("c2"), lambda x,c1,c2: x*UOp.const(x.dtype, exec_alu(BinaryOps.MUL, x.dtype, [c1.arg, c2.arg]))),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var("x") % UOp.const(None, 1), lambda x: UOp.const(x.dtype, 0)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
line:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mod__(self, x): return UOp.alu(BinaryOps.MOD, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var("x") * UOp.cvar("c0") + UOp.var("x") * UOp.cvar("c1"), lambda x,c0,c1: x*exec_alu(BinaryOps.ADD, x.dtype, [c0.arg, c1.arg])),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   ((UOp.var("x") * UOp.cvar("c0")) // UOp.cvar("c0"), lambda x,c0: x if c0.arg != 0 else None),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   ((UOp.var("x") * UOp.var("x2")) / UOp.var("x2"), lambda x,x2: x),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line: constant_folder = PatternMatcher([
line:   ((UOp.var("x") // UOp.cvar("c0")) // UOp.cvar("c1"), lambda x,c0,c1: x//UOp.const(x.dtype, exec_alu(BinaryOps.MUL, x.dtype, [c0.arg, c1.arg]))),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __floordiv__(self, x): return UOp.alu(BinaryOps.IDIV, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   ((UOp.var("x") / UOp.var("x2")) / UOp.var("x3"), lambda x,x2,x3: x/(x2*x3)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __truediv__(self, x): return UOp.alu(BinaryOps.MUL, self, UOp.alu(UnaryOps.RECIP, ufix(self.dtype, x)))
line: constant_folder = PatternMatcher([
line:   ((UOp.cvar("c0") + UOp.var("x")).lt(UOp.cvar("c1")),
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
line:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
line:     lambda x,c0,c1: UOp.lt(x, UOp.const(x.dtype, exec_alu(BinaryOps.ADD, x.dtype, [c1.arg, -c0.arg])))),
line:   ((UOp.cvar("c0") + UOp.var("x")).lt(UOp.cvar("c1")),
line: constant_folder = PatternMatcher([
line:   (UOp.var("x") + UOp.var("x") * UOp.cvar("c0"), lambda x,c0: x*UOp.const(x.dtype, c0.arg+1)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
line:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __mul__(self, x): return UOp.alu(BinaryOps.MUL, self, ufix(self.dtype, x))
call:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __add__(self, x): return UOp.alu(BinaryOps.ADD, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var("x").ne(0), lambda x: x.cast(dtypes.bool)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
line:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.var("x", dtype=dtypes.bool).ne(1), lambda x: -x),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
line:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def ne(self, x): return UOp.alu(BinaryOps.CMPNE, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp.store(UOp.var("buf"), UOp.var("idx"), UOp.alu(TernaryOps.WHERE, UOp.var("gate"), UOp.var("alt"), UOp.load(UOp.var("buf"), UOp.var("idx")))),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
retu:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
call:   @staticmethod
line:   def store(*src:UOp, **kwargs): return UOp(UOps.STORE, None, tuple(src)+tuple(kwargs.values()))
retu:   def store(*src:UOp, **kwargs): return UOp(UOps.STORE, None, tuple(src)+tuple(kwargs.values()))
line:    lambda buf, idx, gate, alt: UOp.store(buf, idx, alt, gate)),
line:   (UOp.store(UOp.var("buf"), UOp.var("idx"), UOp.alu(TernaryOps.WHERE, UOp.var("gate"), UOp.var("alt"), UOp.load(UOp.var("buf"), UOp.var("idx")))),
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
retu:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:    lambda root, val, v0, v1, v2, v3: UOp(UOps.PHI, root.dtype, (val, UOp(UOps.VECTORIZE, val.dtype, (v0, v1, v2, v3))))),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(4))).name("root"),
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
call:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
call:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
call:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
retu:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:    lambda root, val, v0, v1: UOp(UOps.PHI, root.dtype, (val, UOp(UOps.VECTORIZE, val.dtype, (v0, v1))))),
line:   (UOp(UOps.VECTORIZE, src=tuple(UOp(UOps.PHI, src=(UOp(UOps.GEP, src=(UOp.var("val"),), arg=i), UOp.var(f"v{i}"))) for i in range(2))).name("root"),
line: constant_folder = PatternMatcher([
line:   (UOp.lt(-UOp.var('x'), UOp.cvar('c', dtypes.int)), lambda c,x: UOp.lt(UOp.const(c.dtype, -c.arg), x)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
line:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def __neg__(self): return UOp.alu(UnaryOps.NEG, self)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
line:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
call: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
line: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
retu: def ufix(dtype: Optional[DType], x): return UOp.const(dtype, x) if not isinstance(x, UOp) else x
call:   @staticmethod
line:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def alu(arg, *src:UOp): return UOp(UOps.ALU, dtypes.bool if arg in {BinaryOps.CMPLT, BinaryOps.CMPNE} else src[-1].dtype, src, arg)
retu:   def lt(self, x): return UOp.alu(BinaryOps.CMPLT, self, ufix(self.dtype, x))
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.CAST).name("root"), lambda root: root.src[0] if str(root.dtype) == str(root.src[0].dtype) else None),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.VECTORIZE).name("root"), lambda root: root.src[0] if str(root.dtype) == str(root.src[0].dtype) else None),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line: constant_folder = PatternMatcher([
line:   (UOp.load(UOp.var("buf"), UOp.var("idx"), UOp.const(dtypes.bool, True), UOp.cvar("var")), lambda buf,idx,var: UOp.load(buf, idx, dtype=var.dtype)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
retu:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
line: constant_folder = PatternMatcher([
line:   (UOp.load(UOp.var("buf"), UOp.var("idx"), UOp.const(dtypes.bool, True), UOp.cvar("var"), UOp.var("barrier")),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
retu:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
line:    lambda buf,idx,var,barrier: UOp.load(buf, idx, barrier, dtype=var.dtype)),
line:   (UOp.load(UOp.var("buf"), UOp.var("idx"), UOp.const(dtypes.bool, True), UOp.cvar("var"), UOp.var("barrier")),
line: constant_folder = PatternMatcher([
line:   (UOp.load(UOp.var(), UOp.var(), UOp.const(dtypes.bool, False), UOp.cvar("var")), lambda var: var),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
retu:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
line: constant_folder = PatternMatcher([
line:   (UOp.load(UOp.var(), UOp.var(), UOp.const(dtypes.bool, False), UOp.cvar("var"), UOp.var()), lambda var: var),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def cvar(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.CONST, dtype=dtype).name(name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
retu:   def load(*src:UOp, dtype:Optional[DType]=None, **kwargs): return UOp(UOps.LOAD, dtype, tuple(src)+tuple(kwargs.values()))
line: constant_folder = PatternMatcher([
line:   (UOp.store(UOp.var("buf"), UOp.var("idx"), UOp.var("val"), UOp.const(dtypes.bool, True)), UOp.store),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:   def store(*src:UOp, **kwargs): return UOp(UOps.STORE, None, tuple(src)+tuple(kwargs.values()))
retu:   def store(*src:UOp, **kwargs): return UOp(UOps.STORE, None, tuple(src)+tuple(kwargs.values()))
line: constant_folder = PatternMatcher([
line:   (UOp.store(UOp.var(), UOp.var(), UOp.var(), UOp.const(dtypes.bool, False)), lambda: UOp(UOps.NOOP)),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
call:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
line:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
retu:   def const(self:Union[UOp, DType, None], b:ConstType|Variable): return UOp._const(self.dtype if isinstance(self, UOp) else self, b)
call:   @staticmethod
line:   def store(*src:UOp, **kwargs): return UOp(UOps.STORE, None, tuple(src)+tuple(kwargs.values()))
retu:   def store(*src:UOp, **kwargs): return UOp(UOps.STORE, None, tuple(src)+tuple(kwargs.values()))
line: constant_folder = PatternMatcher([
line:   (UOp(UOps.SINK).name("root"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:     lambda root: UOp(UOps.SINK, root.dtype, a, root.arg) if len(a:=tuple(x for x in root.src if x.op is not UOps.NOOP)) != len(root.src) else None),
line:   (UOp(UOps.SINK).name("root"),
line: constant_folder = PatternMatcher([
call:   def __init__(self, patterns:List[Tuple[Union[UPat, UOp], Callable]]):
line:     self.patterns = patterns
line:     self.pdict: DefaultDict[Tuple[UOps, Any], List[Tuple[UPat, Callable]]] = defaultdict(list)
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:       self.src = list(itertools.permutations(src))
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
line:       self.arg in {BinaryOps.ADD, BinaryOps.MUL, BinaryOps.MAX, BinaryOps.CMPNE, BinaryOps.XOR, BinaryOps.AND, BinaryOps.OR})
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
retu:     for p,fxn in self.patterns:
line: def _expand_arg_to_idx(args:Tuple[Tuple[int, int], ...], rpk:Dict[int, int]) -> int:
line: def _choices_from_args(args:Tuple[Tuple[int, int], ...]) -> List[Dict[int, int]]:
line: def do_expand(root:UOp):
line: acc_number = 0
line: def do_reduce_with_expand(root):
line: def do_contract(con:UOp):
line: def no_vectorized_alu(alu):
line: expander = PatternMatcher([
line:   (UPat({UOps.ALU, UOps.CAST, UOps.BITCAST, UOps.GEP, UOps.WMMA, UOps.LOAD, UOps.STORE,
line:          UOps.VECTORIZE, UOps.REDUCE, UOps.EXPAND, UOps.IF}, name="root"), do_expand),
line:   (UPat({UOps.ALU, UOps.CAST, UOps.BITCAST, UOps.GEP, UOps.WMMA, UOps.LOAD, UOps.STORE,
line:          UOps.VECTORIZE, UOps.REDUCE, UOps.EXPAND, UOps.IF}, name="root"), do_expand),
line:   (UPat({UOps.ALU, UOps.CAST, UOps.BITCAST, UOps.GEP, UOps.WMMA, UOps.LOAD, UOps.STORE,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line:          UOps.VECTORIZE, UOps.REDUCE, UOps.EXPAND, UOps.IF}, name="root"), do_expand),
line:   (UPat({UOps.ALU, UOps.CAST, UOps.BITCAST, UOps.GEP, UOps.WMMA, UOps.LOAD, UOps.STORE,
line:   (UOp(UOps.REDUCE).name("root"), do_reduce_with_expand),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.CONTRACT).name("con"), do_contract),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.SINK).name("root"),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:    lambda root: UOp(UOps.SINK, root.dtype, a, root.arg)
line:   (UOp(UOps.SINK).name("root"),
line:   (UOp(UOps.BARRIER, src=(UOp(UOps.EXPAND).name("ex"),)), lambda ex: UOp(UOps.EXPAND, None, (UOp(UOps.BARRIER, None, ex.src),)*len(ex.src), ex.arg)),
call:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
retu:   def name(self, name:Optional[str]): return UOp(UOps.VAR, src=(self,), arg=name)
line:   (UOp(UOps.EXPAND, src=(UOp.var('x'),), arg=()), lambda x: x),
call:   @staticmethod
line:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
retu:   def var(name:Optional[str]=None, dtype:Optional[DType]=None): return UOp(UOps.VAR, dtype=dtype, arg=name)
line:   (UPat({UOps.ALU, UOps.CAST}, name="alu"), no_vectorized_alu),
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
line: expander = PatternMatcher([
call:   def __init__(self, patterns:List[Tuple[Union[UPat, UOp], Callable]]):
line:     self.patterns = patterns
line:     self.pdict: DefaultDict[Tuple[UOps, Any], List[Tuple[UPat, Callable]]] = defaultdict(list)
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def commutative(self) -> bool:
line:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
retu:     return self.op is UOps.UNMUL or (self.op is UOps.ALU and \
call:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   @staticmethod
line:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:     elif isinstance(src, UPat):
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     if u.op is UOps.VAR: return UPat(name=name or u.arg, dtype=u.dtype) if len(u.src) == 0 else UPat.compile(u.src[0], name or u.arg)
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:                 name, u.dtype, allow_any_len=(isinstance(name, str) and 'allow_any_len' in name))
line:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
call:   def __init__(self, op:Optional[Union[UOps, Set[UOps]]]=None, arg:Any=None, src:Optional[Union[Tuple[UPat, ...], List[UPat], UPat]]=None,
line:     self.op: Optional[Tuple[UOps, ...]] = None if op is None else (tuple(op) if isinstance(op, set) else (op,))
line:     self.dtype: Optional[Tuple[DType, ...]] = None if dtype is None else (tuple(dtype) if isinstance(dtype, set) else (dtype,))
line:     self.arg = arg
line:     self.src: Any = None
line:     if isinstance(src, list):
line:     elif isinstance(src, tuple):
line:       self.src = [src]
line:     self.name: Optional[str] = name
line:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     self.allowed_len: int = 0 if allow_any_len or isinstance(src, UPat) or src is None else len(src)
retu:     return UPat(u.op, u.arg, (list if u.commutative() else tuple)([UPat.compile(src) for src in u.src]) if u.src != () else None,
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
line:       if isinstance(p, UOp): p = UPat.compile(p)
line:       assert p.op is not None
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:       for uop in p.op: self.pdict[(uop, p.arg)].append((p, fxn))
line:     for p,fxn in self.patterns:
retu:     for p,fxn in self.patterns:
line: def get_children_dfs(u:UOp, children:Dict[UOp, List[UOp]], in_degree:Dict[UOp, int]):
line: def graph_rewrite(sink:UOp, pm:PatternMatcher) -> UOp:
line: class UOpGraph:
call: class UOpGraph:
line: class UOpGraph:
line:   def __init__(self, sink:Union[UOp, List[UOp]], opts:Optional[Renderer]=None):
line:   def __reduce__(self): return self.__class__, (self.sink, self.opts)
line:   def __iter__(self) -> Iterator[UOp]: return iter(self.uops)
line:   def __getitem__(self, index) -> UOp: return self.uops[index]
line:   def vars(self) -> List[Variable]: return sorted([x.arg for x in self.uops if x.op is UOps.DEFINE_VAR], key=lambda v: v.expr)
line:   def globals(self) -> List[Tuple[int, bool]]: return [x.arg for x in self.uops if x.op is UOps.DEFINE_GLOBAL]
line:   @property
line:   def uops(self) -> List[UOp]:
line:   def graph(self):
line:   def print(self):
line:   cnt = 0
line:   def linearize(self, extra_pm:Optional[PatternMatcher]=None):
retu:   def linearize(self, extra_pm:Optional[PatternMatcher]=None):
retu: class UOpGraph:
line: from tinygrad.shape.symbolic import sym_infer, sint, Variable
line: from tinygrad.dtype import DType
line: @dataclass(frozen=True)
line: class TensorCore: # D = A * B + C, A is (M x K), B is (K x N), C and D are (M x N)
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   dims: Tuple[int,int,int] # N, M, K
line:   dtype_in: DType # dtype for A and B
line:   dtype_out: DType # dtype for C and D
line:   threads: List[Tuple[int,int]] # list of (TC dim,amt) that construct the warp thread structure
line:   thread_local_sizes: List[List[int]] # in each thread, the number of elements stored in registers for each TC dim
line:   def __str__(self): return "_".join(["WMMA"] + list(map(str, self.dims)) + [self.dtype_in.name, self.dtype_out.name])
retu:   def __str__(self): return "_".join(["WMMA"] + list(map(str, self.dims)) + [self.dtype_in.name, self.dtype_out.name])
line: @dataclass(frozen=True)
line: class Program:
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   name:str
line:   src:str
line:   dname:str
line:   global_size:Optional[List[int]]=None
line:   local_size:Optional[List[int]]=None
line:   uops:Optional[UOpGraph]=None
line:   op_estimate:sint=0
line:   mem_estimate:sint=0
line:   @functools.cached_property
line:   def vars(self) -> List[Variable]: return [] if self.uops is None else self.uops.vars()
line:   @functools.cached_property
line:   def globals(self) -> List[Tuple[int, bool]]: return [] if self.uops is None else self.uops.globals()
line:   @functools.cached_property
line:   def outcount(self) -> int: return sum(x[1] for x in self.globals)
line:   @functools.cached_property
line:   def function_name(self) -> str: return to_function_name(self.name)
line:   def launch_dims(self, var_vals:Dict[Variable, int]):
retu:   def launch_dims(self, var_vals:Dict[Variable, int]):
line: class Renderer:
call: class Renderer:
line: class Renderer:
line:   device: str = ""
line:   suffix: str = ""
line:   supports_float4: bool = True
line:   has_local: bool = True
line:   has_shared: bool = True
line:   global_max: Optional[Tuple[int, ...]] = (0x8FFFFFFF,) * (3) # TODO: UOps.SPECIAL int32 indexes right now
line:   local_max: Optional[Tuple[int, ...]] = (0x8FFFFFFF,) * (3) # TODO: UOps.SPECIAL int32 indexes right now
line:   shared_max: int = 32768
line:   tensor_cores: List[TensorCore] = []
line:   def render(self, name:str, uops:UOpGraph) -> str: raise NotImplementedError("needs a renderer")
retu:   def render(self, name:str, uops:UOpGraph) -> str: raise NotImplementedError("needs a renderer")
retu: class Renderer:
line: class _Device:
call: class _Device:
line: class _Device:
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   @functools.lru_cache(maxsize=None)  # this class is a singleton, pylint: disable=method-cache-max-size-none
line:   def _canonicalize(self, device:str) -> str: return (device.split(":", 1)[0].upper() + ((":"+device.split(":", 1)[1]) if ':' in device else '')).replace(":0", "")   # noqa: E501
line:   def canonicalize(self, device:Optional[str]) -> str: return self._canonicalize(device) if device is not None else Device.DEFAULT
line:   def __getitem__(self, ix:str) -> Compiled: return self.__get_canonicalized_item(self.canonicalize(ix))
line:   @functools.lru_cache(maxsize=None)  # this class is a singleton, pylint: disable=method-cache-max-size-none
line:   def __get_canonicalized_item(self, ix:str) -> Compiled:
line:   @functools.cached_property
line:   def DEFAULT(self) -> str:
retu:   def DEFAULT(self) -> str:
line: Device = _Device()
call:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
call:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
retu:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
retu:   def __init__(self) -> None: self._devices: List[str] = [x.stem[len("ops_"):].upper() for x in (pathlib.Path(__file__).parent/"runtime").iterdir() if x.stem.startswith("ops_")]  # noqa: E501
line: @dataclass(frozen=True, eq=True)
line: class BufferOptions:
call: @dataclass(frozen=True, eq=True)
line: @dataclass(frozen=True, eq=True)
line:   image: Optional[ImageDType] = None
line:   uncached: bool = False
line:   cpu_access: bool = False
line:   host: bool = False
line:   nolru: bool = False
retu:   nolru: bool = False
line: class Buffer:
call: class Buffer:
line: class Buffer:
line:   def __init__(self, device:str, size:int, dtype:DType, opaque:Any=None, options:Optional[BufferOptions]=None,
line:                initial_value:Optional[bytes]=None, lb_refcount=0, base:Optional[Buffer]=None, offset:int=0, preallocate=False):
line:   def __init__(self, device:str, size:int, dtype:DType, opaque:Any=None, options:Optional[BufferOptions]=None,
line:   @property
line:   def base(self) -> Buffer: return self._base if self._base is not None else self
line:   @property
line:   def lb_refcount(self): return self.base._lb_refcount
line:   def ref(self, cnt): self.base._lb_refcount += cnt
line:   def is_allocated(self) -> bool: return hasattr(self, '_buf')
line:   def ensure_allocated(self) -> Buffer: return self.allocate() if not hasattr(self, '_buf') else self
line:   def allocate(self, opaque=None) -> Buffer:
line:   def __reduce__(self):
line:   @property
line:   def nbytes(self): return self.size*self.dtype.itemsize
line:   def __del__(self):
line:   def __repr__(self):
line:   def as_buffer(self, allow_zero_copy=False, force_zero_copy=False) -> memoryview:
line:   def copyin(self, mv:memoryview):
line:   def copyout(self, mv:memoryview) -> memoryview:
line:   def view(self, size:int, dtype:DType, offset:int) -> Buffer:
retu:   def view(self, size:int, dtype:DType, offset:int) -> Buffer:
line: class Allocator:
call: class Allocator:
line: class Allocator:
line:   def alloc(self, size:int, options:Optional[BufferOptions]=None):
line:   def _alloc(self, size:int, options:BufferOptions): raise NotImplementedError("need alloc")
line:   def free(self, opaque, size:int, options:Optional[BufferOptions]=None):
line:   def _free(self, opaque, options:BufferOptions): pass  # if opaque is a Python object, you don't need a free
line:   def copyin(self, dest, src:memoryview): raise NotImplementedError("need copyin")
line:   def copyout(self, dest:memoryview, src): raise NotImplementedError("need copyout")
retu:   def copyout(self, dest:memoryview, src): raise NotImplementedError("need copyout")
line: class LRUAllocator(Allocator):  # pylint: disable=abstract-method
call: class LRUAllocator(Allocator):  # pylint: disable=abstract-method
line: class LRUAllocator(Allocator):  # pylint: disable=abstract-method
line:   """
line:   def __init__(self): self.cache: Dict[Tuple[int, Optional[BufferOptions]], Any] = defaultdict(list)
line:   def alloc(self, size:int, options:Optional[BufferOptions]=None):
line:   def free_cache(self):
line:   def free(self, opaque:Any, size:int, options:Optional[BufferOptions]=None):
retu:   def free(self, opaque:Any, size:int, options:Optional[BufferOptions]=None):
line: class _MallocAllocator(LRUAllocator):
call: class _MallocAllocator(LRUAllocator):
line: class _MallocAllocator(LRUAllocator):
line:   def _alloc(self, size:int, options:BufferOptions): return (ctypes.c_uint8 * size)()
line:   def as_buffer(self, src) -> memoryview: return flat_mv(memoryview(src))
line:   def copyin(self, dest, src:memoryview): ctypes.memmove(dest, from_mv(src), len(src))
line:   def copyout(self, dest:memoryview, src): ctypes.memmove(from_mv(dest), src, len(dest))
line:   def offset(self, buf, size:int, offset:int): return from_mv(self.as_buffer(buf)[offset:offset+size])
retu:   def offset(self, buf, size:int, offset:int): return from_mv(self.as_buffer(buf)[offset:offset+size])
line: MallocAllocator = _MallocAllocator()
call:   def __init__(self): self.cache: Dict[Tuple[int, Optional[BufferOptions]], Any] = defaultdict(list)
line:   def __init__(self): self.cache: Dict[Tuple[int, Optional[BufferOptions]], Any] = defaultdict(list)
retu:   def __init__(self): self.cache: Dict[Tuple[int, Optional[BufferOptions]], Any] = defaultdict(list)
line: class CompileError(Exception): pass
call: class CompileError(Exception): pass
line: class CompileError(Exception): pass
retu: class CompileError(Exception): pass
line: class Compiler:
call: class Compiler:
line: class Compiler:
line:   def __init__(self, cachekey:Optional[str]=None): self.cachekey = None if getenv("DISABLE_COMPILER_CACHE") else cachekey
line:   def compile(self, src:str) -> bytes: raise NotImplementedError("need a compile function")
line:   def compile_cached(self, src:str) -> bytes:
retu:   def compile_cached(self, src:str) -> bytes:
line: class Compiled:
call: class Compiled:
line: class Compiled:
line:   def __init__(self, device:str, allocator:Allocator, renderer:Optional[Renderer], compiler:Optional[Compiler], runtime, graph=None):
line:   def synchronize(self):
retu:   def synchronize(self):
line: def hcq_command(func):
line: class HWCommandQueue:
call: class HWCommandQueue:
line: class HWCommandQueue:
line:   """
line:   def __init__(self): self.q, self.binded_device, self.cmds_offset, self.cmds_len, self.cmds_meta = [], None, [], [], []
line:   def __len__(self): return len(self.cmds_offset)
line:   def _patch(self, cmd_idx, offset, data): self.q[(st:=self.cmds_offset[cmd_idx]+offset):st+len(data)] = array.array('I', data)
line:   @hcq_command
line:   def signal(self, signal:HCQSignal, value:int):
call: def hcq_command(func):
line:   def __wrapper(self, *args, **kwargs):
line:   return __wrapper
retu:   return __wrapper
line:   def _signal(self, signal:HCQSignal, value:int): raise NotImplementedError("backend should overload this function")
line:   @hcq_command
line:   def wait(self, signal:HCQSignal, value:int):
call: def hcq_command(func):
line:   def __wrapper(self, *args, **kwargs):
line:   return __wrapper
retu:   return __wrapper
line:   def _wait(self, signal, value): raise NotImplementedError("backend should overload this function")
line:   @hcq_command
line:   def timestamp(self, signal:HCQSignal):
call: def hcq_command(func):
line:   def __wrapper(self, *args, **kwargs):
line:   return __wrapper
retu:   return __wrapper
line:   def _timestamp(self, signal): raise NotImplementedError("backend should overload this function")
line:   def update_signal(self, cmd_idx:int, signal:Optional[Any]=None, value:Optional[int]=None):
line:   def _update_signal(self, cmd_idx:int, signal:Optional[Any], value:Optional[int]): raise NotImplementedError("backend should overload this function")
line:   def update_wait(self, cmd_idx:int, signal:Optional[Any]=None, value:Optional[int]=None):
line:   def _update_wait(self, cmd_idx:int, signal:Optional[Any], value:Optional[int]): raise NotImplementedError("backend should overload this function")
line:   def submit(self, device:HCQCompiled):
line:   def _submit(self, device:HCQCompiled): raise NotImplementedError("backend should overload this function")
retu:   def _submit(self, device:HCQCompiled): raise NotImplementedError("backend should overload this function")
line: class HWComputeQueue(HWCommandQueue):
call: class HWComputeQueue(HWCommandQueue):
line: class HWComputeQueue(HWCommandQueue):
line:   @hcq_command
line:   def memory_barrier(self):
call: def hcq_command(func):
line:   def __wrapper(self, *args, **kwargs):
line:   return __wrapper
retu:   return __wrapper
line:   def _memory_barrier(self): pass
line:   @hcq_command
line:   def exec(self, prg:HCQProgram, kernargs:int, global_size:Tuple[int,int,int], local_size:Tuple[int,int,int]):
call: def hcq_command(func):
line:   def __wrapper(self, *args, **kwargs):
line:   return __wrapper
retu:   return __wrapper
line:   def _exec(self, prg, kernargs, global_size, local_size): raise NotImplementedError("backend should overload this function")
line:   def update_exec(self, cmd_idx:int, global_size:Tuple[int,int,int], local_size:Tuple[int,int,int]):
line:   def _update_exec(self, cmd_idx, global_size, local_size): raise NotImplementedError("backend should overload this function")
retu:   def _update_exec(self, cmd_idx, global_size, local_size): raise NotImplementedError("backend should overload this function")
line: class HWCopyQueue(HWCommandQueue):
call: class HWCopyQueue(HWCommandQueue):
line: class HWCopyQueue(HWCommandQueue):
line:   @hcq_command
line:   def copy(self, dest:HCQBuffer, src:HCQBuffer, copy_size:int):
call: def hcq_command(func):
line:   def __wrapper(self, *args, **kwargs):
line:   return __wrapper
retu:   return __wrapper
line:   def _copy(self, dest:HCQBuffer, src:HCQBuffer, copy_size:int): raise NotImplementedError("backend should overload this function")
line:   def update_copy(self, cmd_idx:int, dest:Optional[HCQBuffer]=None, src:Optional[HCQBuffer]=None):
line:   def _update_copy(self, cmd_idx, dest, src): raise NotImplementedError("backend should overload this function")
retu:   def _update_copy(self, cmd_idx, dest, src): raise NotImplementedError("backend should overload this function")
line: class HCQSignal:
call: class HCQSignal:
line: class HCQSignal:
line:   @property
line:   def value(self) -> int: return self._get_value()
line:   @value.setter
line:   def value(self, new_value:int): self._set_value(new_value)
line:   def _get_value(self) -> int: raise NotImplementedError("_get_value() method must be implemented")
line:   def _set_value(self, new_value:int): raise NotImplementedError("_set_value() method must be implemented")
line:   @property
line:   def timestamp(self) -> float:
line:   def _get_timestamp(self) -> float: raise NotImplementedError("_get_timestamp() method must be implemented")
line:   def wait(self, value:int, timeout:int=10000):
retu:   def wait(self, value:int, timeout:int=10000):
line: @contextlib.contextmanager
line: def hcq_profile(dev, enabled, desc, queue_type=None, queue=None):
line: class HCQProgram:
call: class HCQProgram:
line: class HCQProgram:
line:   def __init__(self, kernargs_alloc_size:int, kernargs_args_offset:int=0):
line:   def fill_kernargs(self, kernargs_ptr:int, bufs:Tuple[Any, ...], vals:Tuple[int, ...]=()): raise NotImplementedError("need fill_kernargs")
retu:   def fill_kernargs(self, kernargs_ptr:int, bufs:Tuple[Any, ...], vals:Tuple[int, ...]=()): raise NotImplementedError("need fill_kernargs")
line: class HCQCompiled(Compiled):
call: class HCQCompiled(Compiled):
line: class HCQCompiled(Compiled):
line:   """
line:   def __init__(self, device:str, allocator:Allocator, renderer:Renderer, compiler:Compiler, runtime, signal_t:Type[HCQSignal],
line:   def _gpu2cpu_time(self, gpu_time:float, is_copy:bool) -> float:
line:   def _prof_setup(self):
line:   def _prof_process_events(self):
line:   def _prof_finalize(self):
line:   def _wrap_timeline_signal(self):
retu:   def _wrap_timeline_signal(self):
line: class HCQBuffer(Protocol): va_addr:int; size:int # noqa: E702
call: class HCQBuffer(Protocol): va_addr:int; size:int # noqa: E702
line: class HCQBuffer(Protocol): va_addr:int; size:int # noqa: E702
retu: class HCQBuffer(Protocol): va_addr:int; size:int # noqa: E702
line: class HCQAllocator(LRUAllocator): # pylint: disable=abstract-method
call: class HCQAllocator(LRUAllocator): # pylint: disable=abstract-method
line: class HCQAllocator(LRUAllocator): # pylint: disable=abstract-method
line:   """
line:   def __init__(self, device:HCQCompiled, batch_size:int=(2 << 20), batch_cnt:int=32):
line:   def _alloc(self, size:int, options:BufferOptions) -> HCQBuffer: raise NotImplementedError("need hcq compat alloc")
line:   def copyin(self, dest:HCQBuffer, src:memoryview):
line:   def copy_from_disk(self, dest:HCQBuffer, src, size):
line:   def copyout(self, dest:memoryview, src:HCQBuffer):
line:   def transfer(self, dest:HCQBuffer, src:HCQBuffer, sz:int, src_dev, dest_dev):
line:   def offset(self, buf, size:int, offset:int) -> HCQBuffer:
retu:   def offset(self, buf, size:int, offset:int) -> HCQBuffer:
retu: class HCQAllocator(LRUAllocator): # pylint: disable=abstract-method
line: from weakref import ref, ReferenceType, WeakValueDictionary
line: lazycache: WeakValueDictionary[Any, LazyBuffer] = WeakValueDictionary()
line: def create_lazybuffer(device:str, st:ShapeTracker, dtype:DType, op:Optional[Op]=None, arg:Any=None, srcs:Tuple[LazyBuffer, ...]=(),
line:                       base:Optional[LazyBuffer]=None, enable_cache=bool(getenv("LAZYCACHE", 1))):
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line: def create_lazybuffer(device:str, st:ShapeTracker, dtype:DType, op:Optional[Op]=None, arg:Any=None, srcs:Tuple[LazyBuffer, ...]=(),
line: view_supported_devices = {"LLVM", "CLANG", "CUDA", "NV", "AMD", "METAL", "DISK"}
line: class LazyBuffer:
call: class LazyBuffer:
line: class LazyBuffer:
line:                op:Optional[Op]=None, arg:Any=None, srcs:Tuple[LazyBuffer, ...]=(),
line:                base:Optional[LazyBuffer]=None, metadata:Optional[Metadata]=None):
line:   def __init__(self, device:str, st:ShapeTracker, dtype:DType,
line:   def __del__(self):
line:   def __repr__(self) -> str:
line:   @property
line:   def realized(self) -> Optional[Buffer]:
line:   @property
line:   def base(self) -> LazyBuffer: return self._base if self._base is not None else self
line:   @property
line:   def lbs(self) -> List[LazyBuffer]: return [self]
line:   @staticmethod
line:   def metaop(op, shape:Tuple[sint,...], dtype:DType, device:str, arg=None, src:Tuple[LazyBuffer, ...]=(), enable_cache=False) -> LazyBuffer:
line:   def const(self, val:ConstType, shape:Optional[Tuple[sint,...]]=None) -> LazyBuffer:
line:   def is_realized(self) -> bool: return self.base.realized is not None
line:   def assign(self, x:LazyBuffer) -> LazyBuffer:
line:   def can_view(self): return self.st.consecutive and not self.is_unrealized_const() and self.device.split(":")[0] in view_supported_devices
line:   def contiguous(self, allow_buffer_view=True):
line:   def cast(self, dtype:DType, bitcast:bool=False, allow_buffer_view=True):
line:   def is_unrealized_const(self): return self.base.realized is None and self.base.op is MetaOps.CONST and not isinstance(self.base.arg, Variable)
line:   def is_unrealized_unmasked_const(self): return self.is_unrealized_const() and all(v.mask is None for v in self.st.views)
line:   def _copy(self, device:str) -> LazyBuffer:
line:   def copy_to_device(self, device:str, force: bool = False) -> LazyBuffer:
line:   def e(self, op:Union[MetaOps, UnaryOps, BinaryOps, TernaryOps], *in_srcs:LazyBuffer, arg:Optional[Any]=None) -> LazyBuffer:
line:   def _reduce_op(self, op:ReduceOps, axis:Tuple[int, ...]) -> LazyBuffer:
line:   def r(self, op:ReduceOps, axis:Tuple[int, ...]) -> LazyBuffer:
line:   def _view(self, new_st:ShapeTracker) -> LazyBuffer:
line:   def reshape(self, arg:Tuple[sint, ...]): return self._view(self.st.reshape(arg))
line:   def pad(self, arg:Tuple[Tuple[sint, sint], ...]): return self._view(self.st.pad(arg))
line:   def expand(self, arg:Tuple[sint, ...]): return self._view(self.st.expand(arg))
line:   def permute(self, arg:Tuple[int, ...]): return self._view(self.st.permute(arg))
line:   def shrink(self, arg:Tuple[Tuple[sint, sint], ...]): return self._view(self.st.shrink(arg))
line:   def stride(self, arg:Tuple[int, ...]): return self._view(self.st.stride(arg))
retu:   def stride(self, arg:Tuple[int, ...]): return self._view(self.st.stride(arg))
retu: class LazyBuffer:
line: from tinygrad.multi import MultiLazyBuffer
call: from __future__ import annotations
line: from __future__ import annotations
line: from typing import Optional, Union, Any, Tuple, List, Dict
line: import functools, itertools, operator
line: from tinygrad.helpers import all_same, all_int, dedup, round_up, prod, DEBUG, RING
line: from tinygrad.dtype import DType, ConstType
line: from tinygrad.ops import BinaryOps, MetaOps, UnaryOps, TernaryOps, ReduceOps
line: from tinygrad.lazy import LazyBuffer
line: from tinygrad.shape.shapetracker import sint
line: def all_reduce(op: ReduceOps, lbs: List[LazyBuffer]) -> List[LazyBuffer]:
line: def to_sharded(lbs:List[LazyBuffer], axis:int) -> List[LazyBuffer]:
line: class MultiLazyBuffer:
call: class MultiLazyBuffer:
line: class MultiLazyBuffer:
line:   def __init__(self, lbs:List[LazyBuffer], axis:Optional[int], real:Optional[List[bool]]=None):
line:   @property
line:   def shape(self):
line:   @property
line:   def size(self): return sum(x.size for x in self.real_lbs)
line:   @property
line:   def real_lbs(self): return [lb for lb,r in zip(self.lbs, self.real) if r]
line:   def __repr__(self):
line:   @staticmethod
line:   def from_sharded(lb:LazyBuffer, devices:Tuple[str, ...], axis:Optional[int]=None):
line:   def copy_to_device(self, device:str) -> LazyBuffer:
line:   def is_realized(self) -> bool: return all(lb.base.realized is not None for lb, r in zip(self.lbs, self.real) if r is True)
line:   def cast(self, dtype:DType, bitcast:bool=False, allow_buffer_view=True):
line:   def const(self, val:ConstType) -> MultiLazyBuffer: return MultiLazyBuffer([x.const(val) for x in self.lbs], self.axis, self.real)
line:   def assign(self, x:MultiLazyBuffer): return MultiLazyBuffer([s.assign(d) for s,d in zip(self.lbs, x.lbs)], self.axis, self.real)
line:   def contiguous(self): return MultiLazyBuffer([x.contiguous() for x in self.lbs], self.axis, self.real)
line:   def e(self, op:Union[MetaOps, UnaryOps, BinaryOps, TernaryOps], *in_srcs:MultiLazyBuffer, arg:Optional[Any]=None) -> MultiLazyBuffer:
line:   def r(self, op:ReduceOps, axis:Tuple[int, ...]) -> MultiLazyBuffer:
line:   def _shape_to_single_shard(self, shape:Tuple[sint, ...], lb:LazyBuffer) -> Tuple[sint, ...]:
line:   def reshape(self, arg:Tuple[sint, ...]):
line:   def pad(self, arg:Tuple[Tuple[sint, sint], ...]):
line:   def expand(self, arg:Tuple[sint, ...]):
line:   def permute(self, arg:Tuple[int, ...]):
line:   def shrink(self, arg:Tuple[Tuple[sint, sint], ...]):
line:   def stride(self, arg:Tuple[int, ...]):
retu:   def stride(self, arg:Tuple[int, ...]):
retu: class MultiLazyBuffer:
line: from tinygrad.ops import MetaOps, truncate
line: from tinygrad.device import Device, Buffer, BufferOptions
line: from tinygrad.shape.symbolic import sint, Variable, MulNode, SumNode, NumNode, Node
line: from tinygrad.engine.realize import run_schedule
call: from typing import List, Dict, Optional, cast, Generator, Tuple
line: from typing import List, Dict, Optional, cast, Generator, Tuple
line: import time, pprint
line: from dataclasses import dataclass, replace
line: from tinygrad.helpers import colored, getenv, DEBUG, GlobalCounters, ansilen, BEAM, NOOPT, all_int, CAPTURING, Metadata, Context, TRACEMETA
line: from tinygrad.ops import MetaOps, LazyOp
line: from tinygrad.dtype import dtypes
line: from tinygrad.device import Device, Buffer
line: from tinygrad.shape.symbolic import Variable, sym_infer, sint
line: from tinygrad.renderer import Renderer, Program
line: from tinygrad.codegen.kernel import Kernel
call: from __future__ import annotations
line: from __future__ import annotations
line: import itertools, functools
line: from dataclasses import replace
line: from collections import defaultdict
line: from typing import Optional, List, Tuple, cast, Dict, Union, Final, DefaultDict
line: from tinygrad.ops import LazyOp, UnaryOps, BinaryOps, ReduceOps, MemBuffer, ConstBuffer, BufferOps, MetaOps, UNSAFE_PAD_OPS, verify_lazyop, KernelInfo
line: from tinygrad.device import Device
line: from tinygrad.renderer import Renderer, TensorCore, Program
line: from tinygrad.dtype import ImageDType
line: from tinygrad.helpers import all_same, colored, ansilen, dedup, getenv, prod, DEBUG, TC_OPT, USE_TC, round_up, all_int, \
line: from tinygrad.shape.shapetracker import ShapeTracker
line: from tinygrad.shape.symbolic import sint
line: from tinygrad.shape.view import strides_for_shape
line: from tinygrad.codegen.uops import UOps, flops_mem
line: from tinygrad.codegen.uopgraph import UOpGraph
line: from tinygrad.codegen.lowerer import lazyop_to_uop
call: from __future__ import annotations
line: from __future__ import annotations
line: from typing import List, Tuple, cast, Optional, Any, Dict
line: import functools
line: from tinygrad.shape.shapetracker import ShapeTracker, View
line: from tinygrad.shape.symbolic import sint
line: from tinygrad.dtype import dtypes, PtrDType, ImageDType, DType
line: from tinygrad.ops import BufferOps, LazyOp, TernaryOps, ReduceOps, UnaryOps, MetaOps, KernelInfo, MemBuffer
line: from tinygrad.codegen.uops import UOp, UOps
line: from tinygrad.renderer import Renderer
line: from tinygrad.helpers import getenv, all_int, get_contraction
line: from tinygrad.shape.symbolic import Variable, NumNode, SumNode, MulNode, DivNode, ModNode, LtNode, AndNode
line: def variable_to_uop(x, ctx=None) -> UOp: return UOp.const(dtypes.bigint, x) if isinstance(x, int) else x.render(render_ops, ctx)
line: render_ops: Any = { NumNode: lambda self, ops, ctx: UOp.const(dtypes.bigint, self.b),
line:                     MulNode: lambda self, ops, ctx: self.a.render(ops, ctx)*variable_to_uop(self.b, ctx),
line:                     DivNode: lambda self, ops, ctx: self.a.render(ops, ctx)//variable_to_uop(self.b, ctx),
line:                     ModNode: lambda self, ops, ctx: self.a.render(ops, ctx)%variable_to_uop(self.b, ctx),
line:                     LtNode: lambda self, ops, ctx: self.a.render(ops, ctx).lt(variable_to_uop(self.b, ctx)),
line:   Variable: lambda self,ops,ctx: ctx[self] if ctx is not None and self in ctx else UOp(UOps.DEFINE_VAR, dtypes.int32, (), self),
line:   SumNode: lambda self,ops,ctx: functools.reduce(lambda a,b: a+b.render(ops, ctx), self.nodes[1:], self.nodes[0].render(ops,ctx)),
line:   AndNode: lambda self,ops,ctx: functools.reduce(lambda a,b: a*b.render(ops, ctx), self.nodes[1:], self.nodes[0].render(ops,ctx)) }
line: render_ops: Any = { NumNode: lambda self, ops, ctx: UOp.const(dtypes.bigint, self.b),
line: if getenv("UOP_IS_SYMBOLIC"):
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line:   def st_to_uops(st:ShapeTracker, idxs:List[UOp], dtype:DType) -> Tuple[UOp, UOp]:
line: def _limit_dims(dims:Tuple[sint, ...], max_sizes:Tuple[int, ...]):
line: def get_grouped_dims(prefix, dims:Tuple[sint, ...], max_sizes:Optional[Tuple[int, ...]], reverse=False) -> List[UOp]:
line: class IndependentLowerer:
call: class IndependentLowerer:
line: class IndependentLowerer:
line:   def lower(self, ast:LazyOp, opts:Renderer) -> UOp:
line:   def to_uop(self, x:LazyOp) -> UOp:
line:   def _to_uop(self, x:LazyOp) -> UOp:
retu:   def _to_uop(self, x:LazyOp) -> UOp:
line: def lazyop_to_uop(ast:LazyOp, opts:Renderer) -> UOp: return IndependentLowerer().lower(ast, opts)
retu: def lazyop_to_uop(ast:LazyOp, opts:Renderer) -> UOp: return IndependentLowerer().lower(ast, opts)
line: from dataclasses import dataclass
line: from enum import Enum, auto
line: class OptOps(Enum):
call: class OptOps(Enum):
line: class OptOps(Enum):
line:   TC = auto(); UPCAST = auto(); UPCASTMID = auto(); UNROLL = auto(); LOCAL = auto() # noqa: E702
line:   GROUP = auto(); GROUPTOP = auto(); NOLOCALS = auto(); PADTO = auto(); MERGE = auto(); SWAP = auto() # noqa: E702
line:   def __lt__(self, x:OptOps): return self.value < x.value
retu:   def __lt__(self, x:OptOps): return self.value < x.value
line: class KernelOptError(Exception): pass
call: class KernelOptError(Exception): pass
line: class KernelOptError(Exception): pass
retu: class KernelOptError(Exception): pass
line: def check(cond:bool, msg:str=""):
line: @dataclass(frozen=True, order=True)
line: class Opt:
call: @dataclass(frozen=True, order=True)
line: @dataclass(frozen=True, order=True)
line:   op: OptOps
line:   axis: Optional[int] = None
line:   amt: Optional[int] = None
line:   def __repr__(self): return f"Opt(op={self.op}, axis={self.axis}, amt={self.amt})"
line:   def real_axis(self, k:Kernel):
retu:   def real_axis(self, k:Kernel):
line: @dataclass
line: class TensorCoreOptions:
call: @dataclass
line: @dataclass
line:   axes: Tuple[int, ...] # the location of the original N and M axes if still in the shape
line:   axes_exist: Tuple[bool, ...] # true if the original N and M axes are still in the shape
line:   axis_pads: Tuple[Tuple[int, int], ...]
line:   def fix_axes(self, removed_axis:int): # adjust the TC axes if necesssary when a dimension is removed
retu:   def fix_axes(self, removed_axis:int): # adjust the TC axes if necesssary when a dimension is removed
line: class Kernel:
call: class Kernel:
line: class Kernel:
line:   def __init__(self, *ast:LazyOp, opts:Optional[Renderer]=None):
line:   def copy(self):
line:   @property
line:   def membufs(self) -> List[MemBuffer]: return [x for x in self.bufs if isinstance(x, MemBuffer)]
line:   def float4_axis(self, i:int): return [x-(self.shape_len-self.upcasted) for x in self.sts[i].unit_stride_axes() if x >= self.shape_len-self.upcasted and self.sts[i].shape[x]%4 == 0]  # noqa: E501
line:   def upcasted_axis(self, i:int) -> List[Tuple[int, Optional[sint], bool]]:
line:   @property
line:   def first_reduce(self) -> int:
line:   @property
line:   def reduceop(self) -> Optional[LazyOp]: return self.reduceops[0] if len(self.reduceops) > 0 else None
line:   @property
line:   def output_shape(self) -> Tuple[sint, ...]: return self.sts[0].shape
line:   @property
line:   def full_shape(self) -> Tuple[sint, ...]: return self.sts[self.full_buf_index].shape
line:   @property
line:   def full_unupcasted_shape(self) -> Tuple[sint, ...]: return self.full_shape[:self.shape_len-self.upcasted]
line:   @property
line:   def shape_len(self) -> int: return len(self.sts[0].shape)
line:   @property
line:   def upcast_in_mid_reduce_axes(self) -> List[int]:
line:   @property
line:   def global_dims(self) -> int: return self.first_reduce-self.local_dims
line:   def colors(self) -> List[str]:
line:   def colored_shape(self, pad:Optional[int]=None, dense=False) -> str:
line:   def reshape_and_permute(self, new_shape_fxn, axis):
line:   def upcast(self):
line:   def shift_to(self, axis, amount, top=False, insert_before=None):
line:   def simplify_ones(self) -> bool:
line:   def simplify_merge_adjacent(self):
line:   def _create_tc_opts(self, reduceop:LazyOp, tc:TensorCore, axis:int, opt_level:int) -> Optional[TensorCoreOptions]:
line:   def _apply_tc_opt(self, use_tensor_cores:int, axis:int, opt_level:int) -> bool:
line:   def apply_tensor_cores(self, use_tensor_cores=1, extra_opts:Optional[List[Opt]]=None, axis:int=0, tc_opt:Optional[int]=None) -> bool:
line:   def apply_opt(self, opt:Opt, append_opt:bool=True):
line:   def required_optimizations(self) -> Kernel:
line:   def hand_coded_optimizations(self) -> Kernel:
line:   kernel_cnt: Final[DefaultDict[str, int]] = defaultdict(int)
line:   @functools.cached_property
line:   def name(self) -> str:
line:   def get_optimized_ast(self) -> LazyOp:
line:   def linearize(self) -> Kernel:
line:   def to_program(self) -> Program:
retu:   def to_program(self) -> Program:
retu: class Kernel:
line: from tinygrad.engine.schedule import ScheduleItem
call: import sys, pickle, atexit
line: import sys, pickle, atexit
line: from collections import defaultdict, deque
line: from dataclasses import dataclass
line: from typing import Tuple, List, Dict, Optional, Set, DefaultDict, Union, cast, get_args
line: from tinygrad.ops import MetaOps, BufferOps, LazyOp, Op, ReduceOps, ConstBuffer, MemBuffer, UNSAFE_PAD_OPS, UnaryOps, reduce_st
line: from tinygrad.engine.graph import log_lazybuffer, realized_lazybuffer
call: import os, atexit, functools, contextlib
line: import os, atexit, functools, contextlib
line: from collections import defaultdict
line: from typing import List, Any, DefaultDict
line: from tinygrad.ops import UnaryOps, BinaryOps, ReduceOps, MetaOps, BufferOps, TernaryOps
line: from tinygrad.device import Device
line: from tinygrad.helpers import GRAPHPATH, DEBUG, GlobalCounters
line: from tinygrad.codegen.uops import UOps, UOp
line: from tinygrad.shape.symbolic import NumNode
line: from tinygrad.lazy import LazyBuffer
line: with contextlib.suppress(ImportError): import networkx as nx
line: if DEBUG >= 2:
call:   def __ge__(self, x): return self.value >= x
line:   def __ge__(self, x): return self.value >= x
retu:   def __ge__(self, x): return self.value >= x
line: def save_graph(G, fn, opt=""):
line: G:Any = None
line: def init_graph():
line: counts: DefaultDict[type, int] = defaultdict(int)
line: def nm(x):
line: def realized_lazybuffer(lb:'LazyBuffer', num):
line: top_colors = {MetaOps: '#FFFFa0', UnaryOps: "#c0c0c0", ReduceOps: "#FFA0A0", BinaryOps: "#c0c0c0",
line:               TernaryOps: "#c0c0c0", BufferOps: '#a0a0ff'}
line: top_colors = {MetaOps: '#FFFFa0', UnaryOps: "#c0c0c0", ReduceOps: "#FFA0A0", BinaryOps: "#c0c0c0",
line: def log_lazybuffer(lb:'LazyBuffer', scheduled=False):
line: graph_uops_cnt = 0
line: def graph_uops(uops:List[UOp]):
retu: def graph_uops(uops:List[UOp]):
line: from tinygrad.helpers import GRAPH, DEBUG, MULTIOUTPUT, SAVE_SCHEDULE, FUSE_AS_ONE_KERNEL, GlobalCounters, colored, prod, dedup, all_int, \
line: from tinygrad.shape.symbolic import Variable
line: from tinygrad.dtype import ConstType, ImageDType, dtypes
line: from tinygrad.lazy import LazyBuffer
line: from tinygrad.shape.shapetracker import ShapeTracker
line: from tinygrad.device import Buffer, Device
line: sys.setrecursionlimit(10000)
line: logops = open(getenv("LOGOPS", ""), "a") if getenv("LOGOPS", "") else None
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line: @dataclass(frozen=True)
line: class ScheduleItem:
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   ast: LazyOp
line:   bufs: Tuple[Buffer, ...]
line:   metadata: Optional[List[Metadata]] = None
line:   @property
line:   def outputs(self) -> Tuple[Buffer, ...]:
line:   @property
line:   def inputs(self) -> Tuple[Buffer, ...]:
retu:   def inputs(self) -> Tuple[Buffer, ...]:
line: def _recursive_lazyop(buf:LazyBuffer, inputs:List[LazyBuffer], outputs:Tuple[LazyBuffer, ...], var_vals:Dict[Variable, int], st:ShapeTracker,
line:                       realizes:Dict[LazyBuffer, None], assign_targets:Dict[LazyBuffer, LazyBuffer],
line: def _recursive_lazyop(buf:LazyBuffer, inputs:List[LazyBuffer], outputs:Tuple[LazyBuffer, ...], var_vals:Dict[Variable, int], st:ShapeTracker,
line:                       realizes:Dict[LazyBuffer, None], assign_targets:Dict[LazyBuffer, LazyBuffer],
line: def _recursive_lazyop(buf:LazyBuffer, inputs:List[LazyBuffer], outputs:Tuple[LazyBuffer, ...], var_vals:Dict[Variable, int], st:ShapeTracker,
line:                       reduce_info:Dict[LazyBuffer, Tuple[ShapeTracker, Tuple[int, ...]]], cache) -> LazyOp:
line: def _recursive_lazyop(buf:LazyBuffer, inputs:List[LazyBuffer], outputs:Tuple[LazyBuffer, ...], var_vals:Dict[Variable, int], st:ShapeTracker,
line:                       reduce_info:Dict[LazyBuffer, Tuple[ShapeTracker, Tuple[int, ...]]], cache) -> LazyOp:
line: def _recursive_lazyop(buf:LazyBuffer, inputs:List[LazyBuffer], outputs:Tuple[LazyBuffer, ...], var_vals:Dict[Variable, int], st:ShapeTracker,
line: def _recurse_reduceops(buf:LazyBuffer, st:ShapeTracker, realizes:Dict[LazyBuffer, None], outs:List[LazyBuffer], reduce_info:Dict, cache):
line: def _lower_lazybuffer(outs:List[LazyBuffer], realizes:Dict[LazyBuffer, None]):
line:     children:DefaultDict[LazyBuffer, Dict[LazyBuffer, None]], assign_targets:Dict[LazyBuffer, LazyBuffer], scheduled=False):
line: def _recurse_lb(buf:LazyBuffer, realizes:Dict[LazyBuffer, None], allbufs:Dict[LazyBuffer, None], simple_pads:Dict[LazyBuffer, None],\
line:     children:DefaultDict[LazyBuffer, Dict[LazyBuffer, None]], assign_targets:Dict[LazyBuffer, LazyBuffer], scheduled=False):
line: def _recurse_lb(buf:LazyBuffer, realizes:Dict[LazyBuffer, None], allbufs:Dict[LazyBuffer, None], simple_pads:Dict[LazyBuffer, None],\
line:     children:DefaultDict[LazyBuffer, Dict[LazyBuffer, None]], assign_targets:Dict[LazyBuffer, LazyBuffer], scheduled=False):
line: def _recurse_lb(buf:LazyBuffer, realizes:Dict[LazyBuffer, None], allbufs:Dict[LazyBuffer, None], simple_pads:Dict[LazyBuffer, None],\
line: def _is_padding_okay(buf:LazyBuffer, realizes:Dict[LazyBuffer, None]) -> bool:
line: def _recursive_group(tr:LazyBuffer, st:ShapeTracker, r:LazyBuffer, children:DefaultDict[LazyBuffer, Dict[LazyBuffer, None]],
line:                      realizes:Dict[LazyBuffer, None], reduce_for_op:Dict[LazyBuffer, LazyBuffer], group:Set[LazyBuffer], cache:Set):
line: def _recursive_group(tr:LazyBuffer, st:ShapeTracker, r:LazyBuffer, children:DefaultDict[LazyBuffer, Dict[LazyBuffer, None]],
line:                      realizes:Dict[LazyBuffer, None], reduce_for_op:Dict[LazyBuffer, LazyBuffer], group:Set[LazyBuffer], cache:Set):
line: def _recursive_group(tr:LazyBuffer, st:ShapeTracker, r:LazyBuffer, children:DefaultDict[LazyBuffer, Dict[LazyBuffer, None]],
line:                      realizes:Dict[LazyBuffer, None], reduce_for_op:Dict[LazyBuffer, LazyBuffer], group:Set[LazyBuffer], cache:Set):
line: def _recursive_group(tr:LazyBuffer, st:ShapeTracker, r:LazyBuffer, children:DefaultDict[LazyBuffer, Dict[LazyBuffer, None]],
line:                      realizes:Dict[LazyBuffer, None], reduce_for_op:Dict[LazyBuffer, LazyBuffer], group:Set[LazyBuffer], cache:Set):
line: def _recursive_group(tr:LazyBuffer, st:ShapeTracker, r:LazyBuffer, children:DefaultDict[LazyBuffer, Dict[LazyBuffer, None]],
line: def _graph_schedule(outs:List[LazyBuffer], seen:Set[LazyBuffer]):
line: SCHEDULES: List = []
line: def create_schedule_with_vars(outs:List[LazyBuffer], seen:Optional[Set[LazyBuffer]]=None) -> Tuple[List[ScheduleItem], Dict[Variable, int]]:
line: def create_schedule(outs:List[LazyBuffer], seen:Optional[Set[LazyBuffer]]=None) -> List[ScheduleItem]:
line: def _internal_memory_planner(buffers:List[Union[List[Buffer], Tuple[Buffer, ...]]], noopt_buffers=None, debug_prefix="") -> Dict[Buffer, Buffer]:
line: def memory_planner(schedule:List[ScheduleItem]) -> List[ScheduleItem]:
retu: def memory_planner(schedule:List[ScheduleItem]) -> List[ScheduleItem]:
line: logkerns, logkerns_level = open(getenv("LOGKERNS", ""), "a") if getenv("LOGKERNS", "") else None, getenv("LOGKERNS_LEVEL", 1)
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
call: @functools.lru_cache(maxsize=None)
line: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
retu: def getenv(key:str, default=0): return type(default)(os.getenv(key, default))
line: def get_kernel(renderer:Renderer, ast:LazyOp) -> Kernel:
line: class Runner:
call: class Runner:
line: class Runner:
line:   def __init__(self, display_name:str, dname:str, op_estimate:sint=0, mem_estimate:sint=0):
line:   @property
line:   def device(self): return Device[self.dname]
line:   def exec(self, rawbufs:List[Buffer], var_vals:Optional[Dict[Variable, int]]=None) -> Optional[float]:
line:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False) -> Optional[float]:
retu:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False) -> Optional[float]:
line: class CompiledRunner(Runner):
call: class CompiledRunner(Runner):
line: class CompiledRunner(Runner):
line:   def __init__(self, p:Program, precompiled:Optional[bytes]=None):
line:   def __reduce__(self): return self.__class__, (self.p, self.lib)
line:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False) -> Optional[float]:
retu:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False) -> Optional[float]:
line: class CustomOp(Runner):
call: class CustomOp(Runner):
line: class CustomOp(Runner):
line:   def __init__(self, fxn):
line:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False): self.fxn(*rawbufs)
retu:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False): self.fxn(*rawbufs)
line: class EmptyOp(Runner):
call: class EmptyOp(Runner):
line: class EmptyOp(Runner):
line:   def __init__(self, buf:Buffer): super().__init__(colored(f"empty {buf.size:10d} {buf.dtype}", "yellow"), buf.device)
line:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False): pass
retu:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False): pass
line: class ViewOp(Runner):
call: class ViewOp(Runner):
line: class ViewOp(Runner):
line:   def __init__(self, buf:Buffer): super().__init__(colored(f"view {buf.nbytes:8d} @ {buf.offset:<10d}", "yellow"), buf.device)
line:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False):
retu:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False):
line: class BufferCopy(Runner):
call: class BufferCopy(Runner):
line: class BufferCopy(Runner):
line:   def __init__(self, total_sz, dest_device, src_device):
line:   def copy(self, dest, src):
line:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False):
retu:   def __call__(self, rawbufs:List[Buffer], var_vals:Dict[Variable, int], wait=False):
line: class BufferXfer(BufferCopy):
call: class BufferXfer(BufferCopy):
line: class BufferXfer(BufferCopy):
line:   def copy(self, dest, src):
retu:   def copy(self, dest, src):
line: method_cache: Dict[Tuple[str, LazyOp, int, bool], CompiledRunner] = {}
line: def get_runner(dname:str, ast:LazyOp) -> CompiledRunner:
line: @dataclass(frozen=True)
line: class ExecItem:
call: @dataclass(frozen=True)
line: @dataclass(frozen=True)
line:   prg: Runner
line:   bufs: List[Optional[Buffer]]
line:   metadata: Optional[List[Metadata]] = None
line:   def run(self, var_vals:Optional[Dict[Variable, int]]=None, wait=False, jit=False, do_update_stats=True) -> Optional[float]:
retu:   def run(self, var_vals:Optional[Dict[Variable, int]]=None, wait=False, jit=False, do_update_stats=True) -> Optional[float]:
line: def lower_schedule_item(si:ScheduleItem) -> ExecItem:
line: def lower_schedule(schedule:List[ScheduleItem]) -> Generator[ExecItem, None, None]:
line: capturing: List = []  # put classes with an add method in here
line: def run_schedule(schedule:List[ScheduleItem], var_vals:Optional[Dict[Variable, int]]=None, do_update_stats=True):
retu: def run_schedule(schedule:List[ScheduleItem], var_vals:Optional[Dict[Variable, int]]=None, do_update_stats=True):
line: from tinygrad.engine.schedule import ScheduleItem, create_schedule_with_vars, memory_planner
line: class Function:
call: class Function:
line: class Function:
line:   def __init__(self, device:Union[str, Tuple[str, ...]], *tensors:Tensor, metadata:Optional[Metadata]=None):
line:   def forward(self, *args, **kwargs): raise NotImplementedError(f"forward not implemented for {type(self)}")
line:   def backward(self, *args, **kwargs): raise RuntimeError(f"backward not implemented for {type(self)}")
line:   @classmethod
line:   def apply(fxn:Type[Function], *x:Tensor, **kwargs) -> Tensor:
retu:   def apply(fxn:Type[Function], *x:Tensor, **kwargs) -> Tensor:
line: import tinygrad.function as F
call: """This is where the forwards and backwards passes live."""
line: """This is where the forwards and backwards passes live."""
line: import math
line: from typing import Tuple, Optional
line: from tinygrad.helpers import argsort
line: from tinygrad.dtype import dtypes, DType, sum_acc_dtype
line: from tinygrad.ops import UnaryOps, BinaryOps, TernaryOps, ReduceOps
line: from tinygrad.tensor import Function
line: from tinygrad.lazy import LazyBuffer
line: from tinygrad.shape.symbolic import sint
line: class Contiguous(Function):
call: class Contiguous(Function):
line: class Contiguous(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer: return x.contiguous()
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output
line: class ContiguousBackward(Function):
call: class ContiguousBackward(Function):
line: class ContiguousBackward(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer: return x
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.contiguous()
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.contiguous()
line: class Cast(Function):
call: class Cast(Function):
line: class Cast(Function):
line:   def forward(self, x:LazyBuffer, dtype:DType, bitcast:bool=False) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.cast(self.input_dtype, self.bitcast)
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.cast(self.input_dtype, self.bitcast)
line: class Neg(Function):
call: class Neg(Function):
line: class Neg(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer: return x.e(UnaryOps.NEG)
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.e(UnaryOps.NEG)
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.e(UnaryOps.NEG)
line: class Reciprocal(Function):
call: class Reciprocal(Function):
line: class Reciprocal(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
line: class Sin(Function):
call: class Sin(Function):
line: class Sin(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
line: class Relu(Function):
call: class Relu(Function):
line: class Relu(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
line: class Log(Function):
call: class Log(Function):
line: class Log(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.e(BinaryOps.MUL, self.x.e(UnaryOps.RECIP))
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.e(BinaryOps.MUL, self.x.e(UnaryOps.RECIP))
line: class Exp(Function):
call: class Exp(Function):
line: class Exp(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return self.ret.e(BinaryOps.MUL, grad_output)
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return self.ret.e(BinaryOps.MUL, grad_output)
line: class Sqrt(Function):
call: class Sqrt(Function):
line: class Sqrt(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
line: class Sigmoid(Function):
call: class Sigmoid(Function):
line: class Sigmoid(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
line: class Sign(Function):
call: class Sign(Function):
line: class Sign(Function):
line:   def forward(self, x:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.const(0)
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.const(0)
line: class Less(Function):
call: class Less(Function):
line: class Less(Function):
line:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.CMPLT, y)
line:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]: return None, None
retu:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]: return None, None
line: class Neq(Function):
call: class Neq(Function):
line: class Neq(Function):
line:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.CMPNE, y)
line:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]: return None, None
retu:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]: return None, None
line: class Xor(Function):
call: class Xor(Function):
line: class Xor(Function):
line:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.XOR, y)
retu:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.XOR, y)
line: class BitwiseAnd(Function):
call: class BitwiseAnd(Function):
line: class BitwiseAnd(Function):
line:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.AND, y)
retu:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.AND, y)
line: class BitwiseOr(Function):
call: class BitwiseOr(Function):
line: class BitwiseOr(Function):
line:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.OR, y)
retu:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.OR, y)
line: class Threefry(Function):
call: class Threefry(Function):
line: class Threefry(Function):
line:   def forward(self, x:LazyBuffer, seed:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.THREEFRY, seed)
retu:   def forward(self, x:LazyBuffer, seed:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.THREEFRY, seed)
line: class Add(Function):
call: class Add(Function):
line: class Add(Function):
line:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer: return x.e(BinaryOps.ADD, y)
line:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]:
retu:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]:
line: class Mul(Function):
call: class Mul(Function):
line: class Mul(Function):
line:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]:
retu:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]:
line: class Div(Function):
call: class Div(Function):
line: class Div(Function):
line:   def forward(self, x:LazyBuffer, y:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]:
retu:   def backward(self, grad_output:LazyBuffer) -> Tuple[Optional[LazyBuffer], Optional[LazyBuffer]]:
line: class Where(Function):
call: class Where(Function):
line: class Where(Function):
line:   def forward(self, x:LazyBuffer, y:LazyBuffer, z:LazyBuffer) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> Tuple[None, Optional[LazyBuffer], Optional[LazyBuffer]]:
retu:   def backward(self, grad_output:LazyBuffer) -> Tuple[None, Optional[LazyBuffer], Optional[LazyBuffer]]:
line: class Sum(Function):
call: class Sum(Function):
line: class Sum(Function):
line:   def forward(self, x:LazyBuffer, axis:Tuple[int, ...]) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.expand(self.input_shape)
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.expand(self.input_shape)
line: class Max(Function):
call: class Max(Function):
line: class Max(Function):
line:   def forward(self, x:LazyBuffer, axis:Tuple[int, ...]) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
line: class Expand(Function):
call: class Expand(Function):
line: class Expand(Function):
line:   def forward(self, x:LazyBuffer, shape:Tuple[int, ...]) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer:
line: class Reshape(Function):
call: class Reshape(Function):
line: class Reshape(Function):
line:   def forward(self, x:LazyBuffer, shape:Tuple[int, ...]) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.reshape(self.input_shape)
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.reshape(self.input_shape)
line: class Permute(Function):
call: class Permute(Function):
line: class Permute(Function):
line:   def forward(self, x:LazyBuffer, order:Tuple[int, ...]) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.permute(argsort(self.input_order))
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.permute(argsort(self.input_order))
line: class Pad(Function):
call: class Pad(Function):
line: class Pad(Function):
line:   def forward(self, x:LazyBuffer, arg:Tuple[Tuple[int, int], ...]) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.shrink(self.narg)
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.shrink(self.narg)
line: class Shrink(Function):
call: class Shrink(Function):
line: class Shrink(Function):
line:   def forward(self, x:LazyBuffer, arg:Tuple[Tuple[sint, sint], ...]) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.pad(self.narg)
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.pad(self.narg)
line: class Flip(Function):
call: class Flip(Function):
line: class Flip(Function):
line:   def forward(self, x:LazyBuffer, axis:Tuple[int, ...]) -> LazyBuffer:
line:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.stride(self.arg)
retu:   def backward(self, grad_output:LazyBuffer) -> LazyBuffer: return grad_output.stride(self.arg)
retu: class Flip(Function):
line: def _metaop(op, shape:Tuple[sint,...], dtype:DType, device:Union[str, Tuple[str, ...]], arg=None, src:Tuple[LazyBuffer, ...]=()):
line: def _from_np_dtype(npdtype:type) -> DType: return dtypes.fields()[np.dtype(npdtype).name]
line: def _to_np_dtype(dtype:DType) -> Optional[type]: return np.dtype(dtype.fmt).type if dtype.fmt is not None else None
line: def _fromnp(x: np.ndarray) -> LazyBuffer:
line: def _frompy(x:Union[List, Tuple, bytes], dtype:DType) -> LazyBuffer:
line: def _get_winograd_matcols(mat, dims:int, shp:Tuple[sint, ...], device:Union[str, Tuple[str, ...]]) -> List[List[Tensor]]:
line: def _apply_winograd_matrix(mat, t:Tensor, dims:int) -> Tensor:
line: def _pad_left(*shapes:Tuple[sint, ...]) -> Tuple[Tuple[sint, ...], ...]:
line: def _broadcast_shape(*shapes:Tuple[sint, ...]) -> Tuple[sint, ...]:
line: class Tensor:
call: class Tensor:
line: class Tensor:
line:   """
line:   __slots__ = "lazydata", "requires_grad", "grad", "_ctx"
line:   __deletable__ = ('_ctx',)
line:   training: ClassVar[bool] = False
line:   no_grad: ClassVar[bool] = False
line:                device:Optional[Union[str, tuple, list]]=None, dtype:Optional[DType]=None, requires_grad:Optional[bool]=None):
line:   def __init__(self, data:Union[None, ConstType, List, Tuple, LazyBuffer, np.ndarray, bytes, MultiLazyBuffer, Variable],
line:   class train(ContextDecorator):
call:   class train(ContextDecorator):
line:   class train(ContextDecorator):
line:     def __init__(self, mode:bool = True): self.mode = mode
line:     def __enter__(self): self.prev, Tensor.training = Tensor.training, self.mode
line:     def __exit__(self, exc_type, exc_value, traceback): Tensor.training = self.prev
retu:     def __exit__(self, exc_type, exc_value, traceback): Tensor.training = self.prev
line:   class inference_mode(ContextDecorator):
call:   class inference_mode(ContextDecorator):
line:   class inference_mode(ContextDecorator):
line:     def __init__(self, mode:bool = True): self.mode = mode
line:     def __enter__(self): self.prev, Tensor.no_grad = Tensor.no_grad, self.mode
line:     def __exit__(self, exc_type, exc_value, traceback): Tensor.no_grad = self.prev
retu:     def __exit__(self, exc_type, exc_value, traceback): Tensor.no_grad = self.prev
line:   def __repr__(self):
line:   def __hash__(self): return id(self)
line:   def __bool__(self): raise TypeError("__bool__ on Tensor is not defined")
line:   def __len__(self):
line:   @property
line:   def device(self) -> Union[str, Tuple[str, ...]]: return self.lazydata.device
line:   @property
line:   def shape(self) -> Tuple[sint, ...]: return self.lazydata.shape
line:   @property
line:   def dtype(self) -> DType: return self.lazydata.dtype
line:   def schedule_with_vars(self, *lst:Tensor, seen:Optional[Set[LazyBuffer]]=None) -> Tuple[List[ScheduleItem], Dict[Variable, int]]:
line:   def schedule(self, *lst:Tensor, seen:Optional[Set[LazyBuffer]]=None) -> List[ScheduleItem]:
line:   def realize(self, *lst:Tensor, do_update_stats=True) -> Tensor:
line:   def replace(self, x:Tensor) -> Tensor:
line:   def assign(self, x) -> Tensor:
line:   def detach(self) -> Tensor:
line:   def _data(self) -> memoryview:
line:   def data(self) -> memoryview:
line:   def item(self) -> ConstType:
line:   def tolist(self) -> Union[Sequence[ConstType], ConstType]:
line:   def numpy(self) -> np.ndarray:
line:   def to(self, device:Optional[Union[str, Tuple[str, ...]]]) -> Tensor:
line:   def to_(self, device:Optional[Union[str, Tuple[str, ...]]]):
line:   def shard(self, devices:Tuple[str, ...], axis:Optional[int]=None) -> Tensor:
line:   def shard_(self, devices:Tuple[str, ...], axis:Optional[int]=None):
line:   @staticmethod
line:   def from_node(y:Node, **kwargs) -> Tensor:
line:   @staticmethod
line:   def _metaop(op, shape, device:Optional[Union[Tuple[str, ...], str]]=None, dtype:Optional[DType]=None, arg=None, **kwargs):
line:   @staticmethod
line:   def empty(*shape, **kwargs):
line:   _seed: int = int(time.time())
line:   _rng_counter: Optional[Tensor] = None
line:   @staticmethod
line:   def manual_seed(seed=0):
line:   @staticmethod
line:   def rand(*shape, device:Optional[Union[Tuple[str, ...], str]]=None, dtype:Optional[DType]=None, **kwargs):
line:   @staticmethod
line:   def full(shape:Tuple[sint, ...], fill_value:ConstType, **kwargs):
line:   @staticmethod
line:   def zeros(*shape, **kwargs):
line:   @staticmethod
line:   def ones(*shape, **kwargs):
line:   @staticmethod
line:   def arange(start, stop=None, step=1, **kwargs):
line:   @staticmethod
line:   def eye(n:int, m:Optional[int]=None, **kwargs):
line:   def full_like(self, fill_value:ConstType, **kwargs):
line:   def zeros_like(self, **kwargs):
line:   def ones_like(self, **kwargs):
line:   @staticmethod
line:   def randn(*shape, dtype:Optional[DType]=None, **kwargs) -> Tensor:
line:   @staticmethod
line:   def randint(*shape, low=0, high=10, **kwargs) -> Tensor:
line:   @staticmethod
line:   def normal(*shape, mean=0.0, std=1.0, **kwargs) -> Tensor:
line:   @staticmethod
line:   def uniform(*shape, low=0.0, high=1.0, **kwargs) -> Tensor:
line:   @staticmethod
line:   def scaled_uniform(*shape, **kwargs) -> Tensor:
line:   @staticmethod
line:   def glorot_uniform(*shape, **kwargs) -> Tensor:
line:   @staticmethod
line:   def kaiming_uniform(*shape, a:float = 0.01, **kwargs) -> Tensor:
line:   @staticmethod
line:   def kaiming_normal(*shape, a:float = 0.01, **kwargs) -> Tensor:
line:   def multinomial(self:Tensor, num_samples:int = 1, replacement:bool = False) -> Tensor:
line:   def _deepwalk(self):
line:   def backward(self) -> Tensor:
line:   def view(self, *shape) -> Tensor:
line:   def reshape(self, shape, *args) -> Tensor:
line:   def expand(self, shape, *args) -> Tensor:
line:   def permute(self, order, *args) -> Tensor:
line:   def flip(self, axis, *args) -> Tensor:
line:   def shrink(self, arg:Tuple[Optional[Tuple[sint, sint]], ...]) -> Tensor:
line:   def pad(self, arg:Tuple[Optional[Tuple[sint, sint]], ...], value:float=0.0) -> Tensor:
line:   def __getitem__(self, indices) -> Tensor:
line:   def __setitem__(self, indices, v:Union[Tensor, ConstType]) -> None:
line:   def _slice(self, arg:Sequence[Optional[Tuple[int, sint]]], value:float=0) -> Tensor:
line:   def gather(self:Tensor, dim:int, index:Tensor) -> Tensor:
line:   def cat(self:Tensor, *args:Tensor, dim:int=0) -> Tensor:
line:   def stack(self:Tensor, *args:Tensor, dim:int=0) -> Tensor:
line:   def repeat_interleave(self, repeats:int, dim:Optional[int]=None) -> Tensor:
line:   def repeat(self, repeats, *args) -> Tensor:
line:   def _resolve_dim(self, dim:int, *, outer:bool=False) -> int:
line:   def split(self, sizes:Union[int, List[int]], dim:int=0) -> Tuple[Tensor, ...]:
line:   def chunk(self, chunks:int, dim:int=0) -> List[Tensor]:
line:   def squeeze(self, dim:Optional[int]=None) -> Tensor:
line:   def unsqueeze(self, dim:int) -> Tensor:
line:   def pad2d(self, padding:Sequence[int], value:float=0.0) -> Tensor:
line:   @property
line:   def T(self) -> Tensor:
line:   def transpose(self, dim0=1, dim1=0) -> Tensor:
line:   def flatten(self, start_dim=0, end_dim=-1):
line:   def unflatten(self, dim:int, sizes:Tuple[int,...]):
line:   def _reduce(self, fxn:Type[Function], axis:Optional[Union[int, Sequence[int]]]=None, keepdim=False) -> Tensor:
line:   def sum(self, axis:Optional[Union[int, Sequence[int]]]=None, keepdim=False, acc_dtype:Optional[DType]=None):
line:   def max(self, axis:Optional[Union[int, Sequence[int]]]=None, keepdim=False):
line:   def min(self, axis:Optional[Union[int, Sequence[int]]]=None, keepdim=False):
line:   def any(self, axis:Optional[Union[int, Sequence[int]]]=None, keepdim=False):
line:   def all(self, axis:Optional[Union[int, Sequence[int]]]=None, keepdim=False):
line:   def mean(self, axis:Optional[Union[int, Sequence[int]]]=None, keepdim=False):
line:   def var(self, axis:Optional[Union[int, Sequence[int]]]=None, keepdim=False, correction=1):
line:   def std(self, axis:Optional[Union[int, Sequence[int]]]=None, keepdim=False, correction=1):
line:   def _softmax(self, axis):
line:   def softmax(self, axis=-1):
line:   def log_softmax(self, axis=-1):
line:   def logsumexp(self, axis=None, keepdim=False):
line:   def argmax(self, axis=None, keepdim=False):
line:   def argmin(self, axis=None, keepdim=False):
line:   @staticmethod
line:   def einsum(formula:str, *raw_xs, acc_dtype:Optional[DType]=None) -> Tensor:
line:   def _pool(self, k_:Tuple[sint, ...], stride:Union[Tuple[int, ...], int]=1, dilation:Union[Tuple[int, ...], int]=1) -> Tensor:
line:   def _padding2d(self, padding:Union[int, Tuple[int, ...]], dims:int) -> Sequence[int]:
line:   def avg_pool2d(self, kernel_size=(2,2), stride=None, dilation=1, padding=0, count_include_pad=True):
line:   def max_pool2d(self, kernel_size=(2,2), stride=None, dilation=1, padding=0):
line:   def conv2d(self, weight:Tensor, bias:Optional[Tensor]=None, groups=1, stride=1, dilation=1, padding=0, acc_dtype:Optional[DType]=None) -> Tensor:
line:   def conv_transpose2d(self, weight:Tensor, bias:Optional[Tensor]=None, groups=1, stride=1, dilation=1, padding=0, output_padding=0) -> Tensor:
line:   def dot(self, w:Tensor, acc_dtype:Optional[DType]=None) -> Tensor:
line:   def matmul(self, x:Tensor, reverse=False, acc_dtype:Optional[DType]=None) -> Tensor:
line:   def _cumsum(self, axis:int=0, _first_zero=False) -> Tensor:
line:   def cumsum(self, axis:int=0) -> Tensor:
line:   @staticmethod
line:   def _tri(r:sint, c:sint, diagonal:int=0, **kwargs) -> Tensor:
line:   def triu(self, diagonal:int=0) -> Tensor:
line:   def tril(self, diagonal:int=0) -> Tensor:
line:   def interpolate(self, size:Tuple[int, ...], mode:str="linear", align_corners:bool=False) -> Tensor:
line:   def logical_not(self):
line:   def neg(self):
line:   def contiguous(self):
line:   def contiguous_backward(self):
line:   def log(self):
line:   def log2(self):
line:   def exp(self):
line:   def exp2(self):
line:   def relu(self):
line:   def sigmoid(self):
line:   def sqrt(self):
line:   def rsqrt(self):
line:   def sin(self):
line:   def cos(self):
line:   def tan(self):
line:   def trunc(self: Tensor) -> Tensor:
line:   def ceil(self: Tensor) -> Tensor:
line:   def floor(self: Tensor) -> Tensor:
line:   def round(self: Tensor) -> Tensor:
line:   def lerp(self, end: Tensor, weight: Union[Tensor, float]) -> Tensor:
line:   def square(self):
line:   def clip(self, min_=None, max_=None):
line:   def sign(self):
line:   def abs(self):
line:   def reciprocal(self):
line:   def elu(self, alpha=1.0):
line:   def celu(self, alpha=1.0):
line:   def swish(self):
line:   def silu(self):
line:   def relu6(self):
line:   def hardswish(self):
line:   def tanh(self):
line:   def sinh(self):
line:   def cosh(self):
line:   def atanh(self):
line:   def asinh(self):
line:   def acosh(self):
line:   def hardtanh(self, min_val=-1, max_val=1):
line:   def gelu(self):
line:   def quick_gelu(self):
line:   def leakyrelu(self, neg_slope=0.01):
line:   def mish(self):
line:   def softplus(self, beta=1):
line:   def softsign(self):
line:   def _broadcast_to(self, shape:Tuple[sint, ...]) -> Tensor:
line:   def _broadcasted(self, y:Union[Tensor, Node, ConstType], reverse:bool=False, match_dtype:bool=True) -> Tuple[Tensor, Tensor]:
line:   def _to_const_val(self, x:Union[Tensor, ConstType]) -> Union[Tensor, ConstType]:
line:   def add(self, x:Union[Tensor, ConstType], reverse=False) -> Tensor:
line:   def sub(self, x:Union[Tensor, ConstType], reverse=False) -> Tensor:
line:   def mul(self, x:Union[Tensor, ConstType], reverse=False) -> Tensor:
line:   def div(self, x:Union[Tensor, ConstType], reverse=False, upcast=True) -> Tensor:
line:   def xor(self, x:Union[Tensor, ConstType], reverse=False) -> Tensor:
line:   def bitwise_and(self, x:Union[Tensor, ConstType], reverse=False) -> Tensor:
line:   def bitwise_or(self, x:Union[Tensor, ConstType], reverse=False) -> Tensor:
line:   def lshift(self, x:int):
line:   def rshift(self, x:int):
line:   def pow(self, x:Union[Tensor, ConstType], reverse=False) -> Tensor:
line:   def maximum(self, x:Union[Tensor, ConstType]) -> Tensor:
line:   def minimum(self, x:Union[Tensor, ConstType]) -> Tensor:
line:   def where(self:Tensor, x:Union[Tensor, ConstType], y:Union[Tensor, ConstType]):
line:   def masked_fill(self:Tensor, mask:Tensor, value:Union[Tensor, ConstType]): return mask.where(value, self)
line:   def __neg__(self) -> Tensor: return self.neg()
line:   def __add__(self, x) -> Tensor: return self.add(x)
line:   def __sub__(self, x) -> Tensor: return self.sub(x)
line:   def __mul__(self, x) -> Tensor: return self.mul(x)
line:   def __pow__(self, x) -> Tensor: return self.pow(x)
line:   def __truediv__(self, x) -> Tensor: return self.div(x)
line:   def __matmul__(self, x) -> Tensor: return self.matmul(x)
line:   def __and__(self, x) -> Tensor: return self.bitwise_and(x)
line:   def __or__(self, x) -> Tensor: return self.bitwise_or(x)
line:   def __xor__(self, x) -> Tensor: return self.xor(x)
line:   def __lshift__(self, x) -> Tensor: return self.lshift(x)
line:   def __rshift__(self, x) -> Tensor: return self.rshift(x)
line:   def __radd__(self, x) -> Tensor: return self.add(x, True)
line:   def __rsub__(self, x) -> Tensor: return self.sub(x, True)
line:   def __rmul__(self, x) -> Tensor: return self.mul(x, True)
line:   def __rpow__(self, x) -> Tensor: return self.pow(x, True)
line:   def __rtruediv__(self, x) -> Tensor: return self.div(x, True)
line:   def __rmatmul__(self, x) -> Tensor: return self.matmul(x, True)
line:   def __rand__(self, x) -> Tensor: return self.bitwise_and(x, True)
line:   def __ror__(self, x) -> Tensor: return self.bitwise_or(x, True)
line:   def __rxor__(self, x) -> Tensor: return self.xor(x, True)
line:   def __iadd__(self, x) -> Tensor: return self.assign(self.add(x))
line:   def __isub__(self, x) -> Tensor: return self.assign(self.sub(x))
line:   def __imul__(self, x) -> Tensor: return self.assign(self.mul(x))
line:   def __ipow__(self, x) -> Tensor: return self.assign(self.pow(x))
line:   def __itruediv__(self, x) -> Tensor: return self.assign(self.div(x))
line:   def __imatmul__(self, x) -> Tensor: return self.assign(self.matmul(x))
line:   def __iand__(self, x) -> Tensor: return self.assign(self.bitwise_and(x))
line:   def __ior__(self, x) -> Tensor: return self.assign(self.bitwise_or(x))
line:   def __ixor__(self, x) -> Tensor: return self.assign(self.xor(x))
line:   def __ilshift__(self, x) -> Tensor: return self.assign(self.lshift(x))
line:   def __irshift__(self, x) -> Tensor: return self.assign(self.rshift(x))
line:   def __lt__(self, x) -> Tensor: return F.Less.apply(*self._broadcasted(x, False))
line:   def __gt__(self, x) -> Tensor: return F.Less.apply(*self._broadcasted(x, True))
line:   def __ge__(self, x) -> Tensor: return (self<x).logical_not()
line:   def __le__(self, x) -> Tensor: return (self>x).logical_not()
line:   def __ne__(self, x) -> Tensor: return F.Neq.apply(*self._broadcasted(x))  # type: ignore[override]
line:   def __eq__(self, x) -> Tensor: return (self!=x).logical_not()             # type: ignore[override]
line:   def linear(self, weight:Tensor, bias:Optional[Tensor]=None):
line:   def sequential(self, ll:List[Callable[[Tensor], Tensor]]):
line:   def layernorm(self, axis=-1, eps:float=1e-5) -> Tensor:
line:   def batchnorm(self, weight:Optional[Tensor], bias:Optional[Tensor], mean:Tensor, invstd:Tensor, axis:Union[int,Tuple[int,...]]=1) -> Tensor:
line:   def dropout(self, p=0.5) -> Tensor:
line:   def one_hot(self, num_classes:int) -> Tensor:
line:   def scaled_dot_product_attention(self, key:Tensor, value:Tensor, attn_mask:Optional[Tensor]=None,
line:                                    dropout_p:float=0.0, is_causal:bool=False) -> Tensor:
line:   def scaled_dot_product_attention(self, key:Tensor, value:Tensor, attn_mask:Optional[Tensor]=None,
line:   def binary_crossentropy(self, y:Tensor) -> Tensor:
line:   def binary_crossentropy_logits(self, y:Tensor) -> Tensor:
line:   def sparse_categorical_crossentropy(self, Y:Tensor, ignore_index=-1, label_smoothing=0.0) -> Tensor:
line:   @property
line:   def ndim(self) -> int: return len(self.shape)
line:   def numel(self) -> sint: return prod(self.shape)
line:   def element_size(self) -> int: return self.dtype.itemsize
line:   def nbytes(self) -> int: return self.numel() * self.element_size()
line:   def is_floating_point(self) -> bool: return dtypes.is_float(self.dtype)
line:   def size(self, dim=None) -> Union[sint, Tuple[sint, ...]]: return self.shape if dim is None else self.shape[dim]
line:   def llvm_bf16_cast(self, dtype:DType):
line:   def cast(self, dtype:DType) -> Tensor:
line:   def bitcast(self, dtype:DType) -> Tensor:
line:   def float(self) -> Tensor:
line:   def half(self) -> Tensor:
line:   def int(self) -> Tensor:
line:   def bool(self) -> Tensor:
line:   def image_dot(self, w:Tensor, acc_dtype=None):
line:   def image_conv2d(self, weight:Tensor, bias:Optional[Tensor]=None, groups=1, stride=1, dilation=1, padding=0, acc_dtype=None):
retu:   def image_conv2d(self, weight:Tensor, bias:Optional[Tensor]=None, groups=1, stride=1, dilation=1, padding=0, acc_dtype=None):
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: for device in Device._devices: setattr(Tensor, f"{device.lower()}", functools.partialmethod(Tensor.to, device))
line: if IMAGE:
call:   def __bool__(self): return bool(self.value)
line:   def __bool__(self): return bool(self.value)
retu:   def __bool__(self): return bool(self.value)
line: def custom_random(out:Buffer):
line: def _metadata_wrapper(fn):
line: if TRACEMETA >= 1:
call:   def __ge__(self, x): return self.value >= x
line:   def __ge__(self, x): return self.value >= x
retu:   def __ge__(self, x): return self.value >= x
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line:     if name in ["__class__", "__init__", "__repr__", "backward", "sequential"]: continue
line:     setattr(Tensor, name, functools.wraps(fn)(_metadata_wrapper(fn)))
call: def _metadata_wrapper(fn):
line:   def _wrapper(*args, **kwargs):
line:   return _wrapper
retu:   return _wrapper
line:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
retu:   for name, fn in inspect.getmembers(Tensor, inspect.isfunction):
line: from tinygrad.engine.jit import TinyJit                       # noqa: F401
call: from __future__ import annotations
line: from __future__ import annotations
line: from typing import TypeVar, Generic, Callable, List, Tuple, Union, Dict, cast, Optional, Any
line: import functools, itertools, collections
line: from tinygrad.tensor import Tensor
line: from tinygrad.lazy import LazyBuffer
line: from tinygrad.helpers import flatten, merge_dicts, DEBUG, Context, GRAPH, BEAM, getenv, all_int, GraphException, colored, JIT
line: from tinygrad.device import Buffer, Compiled, Device
line: from tinygrad.dtype import DType
line: from tinygrad.shape.shapetracker import ShapeTracker
line: from tinygrad.shape.symbolic import Variable, sint
line: from tinygrad.engine.realize import ExecItem, capturing, EmptyOp, ViewOp, BufferXfer, CompiledRunner, Runner
line: from tinygrad.engine.schedule import _internal_memory_planner
line: from tinygrad.nn.state import get_parameters
call: import math
line: import math
line: from typing import Optional, Union, Tuple
line: from tinygrad.tensor import Tensor
line: from tinygrad.helpers import prod
line: from tinygrad.nn import optim, state, datasets  # noqa: F401
call: # sorted in order of increasing complexity
line: from typing import List
line: from tinygrad.helpers import dedup, flatten, getenv
line: from tinygrad.tensor import Tensor
line: from tinygrad.dtype import dtypes, least_upper_dtype
line: class Optimizer:
call: class Optimizer:
line: class Optimizer:
line:   """
line:   def __init__(self, params: List[Tensor], lr: float):
line:   def zero_grad(self):
line:   def step(self):
line:   def schedule_step(self) -> List[Tensor]:
line:   def _step(self) -> List[Tensor]: raise NotImplementedError
retu:   def _step(self) -> List[Tensor]: raise NotImplementedError
line: class OptimizerGroup(Optimizer):
call: class OptimizerGroup(Optimizer):
line: class OptimizerGroup(Optimizer):
line:   """
line:   def __init__(self, *optimizers: Optimizer): # pylint: disable=super-init-not-called
line:   def __getitem__(self, i): return self.optimizers[i]
line:   def zero_grad(self): [o.zero_grad() for o in self.optimizers]
line:   def _step(self) -> List[Tensor]: return [x for o in self.optimizers for x in o._step()]
retu:   def _step(self) -> List[Tensor]: return [x for o in self.optimizers for x in o._step()]
line: def SGD(params: List[Tensor], lr=0.001, momentum=0.0, weight_decay=0.0, nesterov=False, classic=False):
line: class LARS(Optimizer):
call: class LARS(Optimizer):
line: class LARS(Optimizer):
line:   """
line:   def __init__(self, params:List[Tensor], lr=0.001, momentum=0.9, weight_decay=1e-4, nesterov=False, classic=True, tcoef=0.001):
line:   def _step(self) -> List[Tensor]:
retu:   def _step(self) -> List[Tensor]:
line: def AdamW(params: List[Tensor], lr=0.001, b1=0.9, b2=0.999, eps=1e-8, weight_decay=0.01):
line: def Adam(params: List[Tensor], lr=0.001, b1=0.9, b2=0.999, eps=1e-8):
line: class LAMB(Optimizer):
call: class LAMB(Optimizer):
line: class LAMB(Optimizer):
line:   """
line:   def __init__(self, params: List[Tensor], lr=0.001, b1=0.9, b2=0.999, eps=1e-6, weight_decay=0.0, adam=False):
line:   def _step(self) -> List[Tensor]:
retu:   def _step(self) -> List[Tensor]:
retu: class LAMB(Optimizer):
call: import os, json, pathlib, zipfile, pickle, tarfile, struct
line: import os, json, pathlib, zipfile, pickle, tarfile, struct
line: from typing import Dict, Union, List, Optional, Any, Tuple
line: from tinygrad.tensor import Tensor
line: from tinygrad.dtype import dtypes
line: from tinygrad.helpers import prod, argsort, DEBUG, Timing, CI, unwrap, GlobalCounters, tqdm
line: from tinygrad.shape.view import strides_for_shape
line: from tinygrad.multi import MultiLazyBuffer
line: safe_dtypes = {"BOOL":dtypes.bool, "I8":dtypes.int8, "U8":dtypes.uint8, "I16":dtypes.int16, "U16":dtypes.uint16, "I32":dtypes.int, "U32":dtypes.uint,
line:                "I64":dtypes.int64, "U64":dtypes.uint64, "F16":dtypes.float16, "BF16":dtypes.bfloat16, "F32":dtypes.float32, "F64":dtypes.float64}
line: safe_dtypes = {"BOOL":dtypes.bool, "I8":dtypes.int8, "U8":dtypes.uint8, "I16":dtypes.int16, "U16":dtypes.uint16, "I32":dtypes.int, "U32":dtypes.uint,
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
call: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
retu: inverse_safe_dtypes = {v:k for k,v in safe_dtypes.items()}
line: def safe_load_metadata(fn:Union[Tensor,str]) -> Tuple[Tensor, int, Any]:
line: def safe_load(fn:Union[Tensor,str]) -> Dict[str, Tensor]:
line: def safe_save(tensors:Dict[str, Tensor], fn:str, metadata:Optional[Dict[str, Any]]=None):
line: from collections import OrderedDict
line: def get_state_dict(obj, prefix:str='', tensor_type=Tensor) -> Dict[str, Tensor]:
line: def get_parameters(obj) -> List[Tensor]:
line: def load_state_dict(model, state_dict:Dict[str, Tensor], strict=True, verbose=True, consume=False) -> None:
line: def torch_load(fn:str) -> Dict[str, Tensor]:
retu: def torch_load(fn:str) -> Dict[str, Tensor]:
call: import gzip
line: import gzip
line: from tinygrad.tensor import Tensor
line: from tinygrad.helpers import fetch
line: def _fetch_mnist(file, offset): return Tensor(gzip.open(fetch("https://storage.googleapis.com/cvdf-datasets/mnist/"+file)).read()[offset:])
line: def mnist():
retu: def mnist():
line: class BatchNorm:
call: class BatchNorm:
line: class BatchNorm:
line:   """
line:   def __init__(self, sz:int, eps=1e-5, affine=True, track_running_stats=True, momentum=0.1):
line:   def __call__(self, x:Tensor):
retu:   def __call__(self, x:Tensor):
line: BatchNorm2d = BatchNorm3d = BatchNorm
line: def Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True):
line: class Conv2d:
call: class Conv2d:
line: class Conv2d:
line:   """
line:   def __init__(self, in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True):
line:   def __call__(self, x:Tensor):
retu:   def __call__(self, x:Tensor):
line: def ConvTranspose1d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, dilation=1, groups=1, bias=True):
line: class ConvTranspose2d(Conv2d):
call: class ConvTranspose2d(Conv2d):
line: class ConvTranspose2d(Conv2d):
line:   """
line:   def __init__(self, in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, dilation=1, groups=1, bias=True):
line:   def __call__(self, x:Tensor):
retu:   def __call__(self, x:Tensor):
line: class Linear:
call: class Linear:
line: class Linear:
line:   """
line:   def __init__(self, in_features, out_features, bias=True):
line:   def __call__(self, x:Tensor):
retu:   def __call__(self, x:Tensor):
line: class GroupNorm:
call: class GroupNorm:
line: class GroupNorm:
line:   """
line:   def __init__(self, num_groups:int, num_channels:int, eps:float=1e-5, affine:bool=True):
line:   def __call__(self, x:Tensor):
retu:   def __call__(self, x:Tensor):
line: class InstanceNorm:
call: class InstanceNorm:
line: class InstanceNorm:
line:   """
line:   def __init__(self, num_features:int, eps:float=1e-5, affine:bool=True):
line:   def __call__(self, x:Tensor):
retu:   def __call__(self, x:Tensor):
line: class LayerNorm:
call: class LayerNorm:
line: class LayerNorm:
line:   """
line:   def __init__(self, normalized_shape:Union[int, Tuple[int, ...]], eps:float=1e-5, elementwise_affine:bool=True):
line:   def __call__(self, x:Tensor):
retu:   def __call__(self, x:Tensor):
line: class LayerNorm2d(LayerNorm):
call: class LayerNorm2d(LayerNorm):
line: class LayerNorm2d(LayerNorm):
line:   """
line:   def __call__(self, x): return super().__call__(x.permute(0, 2, 3, 1)).permute(0, 3, 1, 2)
retu:   def __call__(self, x): return super().__call__(x.permute(0, 2, 3, 1)).permute(0, 3, 1, 2)
line: class RMSNorm:
call: class RMSNorm:
line: class RMSNorm:
line:   """
line:   def __init__(self, dim, eps=1e-6): self.eps, self.weight = eps, Tensor.ones(dim)
line:   def _norm(self, x:Tensor): return x * (x.pow(2).mean(-1, keepdim=True) + self.eps).rsqrt()
line:   def __call__(self, x:Tensor) -> Tensor: return self._norm(x.float()).cast(x.dtype) * self.weight
retu:   def __call__(self, x:Tensor) -> Tensor: return self._norm(x.float()).cast(x.dtype) * self.weight
line: class Embedding:
call: class Embedding:
line: class Embedding:
line:   """
line:   def __init__(self, vocab_size:int, embed_size:int):
line:   def __call__(self, idx:Tensor) -> Tensor:
retu:   def __call__(self, idx:Tensor) -> Tensor:
retu: class Embedding:
line: from weakref import WeakKeyDictionary
line: def apply_graph_to_jit(jit_cache: List[ExecItem], input_rawbuffers: List[Buffer], var_vals: Dict[Variable, int]) -> List[ExecItem]:
line: def get_input_replace(jit_cache: List[ExecItem], input_rawbuffers:List[Buffer]) -> Dict[Tuple[int, int], int]:
line: class GraphRunner(Runner):  # pylint: disable=abstract-method
call: class GraphRunner(Runner):  # pylint: disable=abstract-method
line: class GraphRunner(Runner):  # pylint: disable=abstract-method
line:   def __init__(self, jit_cache: List[ExecItem], input_rawbuffers: List[Buffer], var_vals: Dict[Variable, int]):
retu:   def __init__(self, jit_cache: List[ExecItem], input_rawbuffers: List[Buffer], var_vals: Dict[Variable, int]):
line: class MultiGraphRunner(GraphRunner):  # pylint: disable=abstract-method
call: class MultiGraphRunner(GraphRunner):  # pylint: disable=abstract-method
line: class MultiGraphRunner(GraphRunner):  # pylint: disable=abstract-method
line:   def __init__(self, jit_cache: List[ExecItem], input_rawbuffers: List[Buffer], var_vals: Dict[Variable, int]):
line:   def _access_resources(self, read, write, new_dependency:Any):
retu:   def _access_resources(self, read, write, new_dependency:Any):
line: ReturnType = TypeVar('ReturnType')
line: class TinyJit(Generic[ReturnType]):
call: class TinyJit(Generic[ReturnType]):
line: class TinyJit(Generic[ReturnType]):
line:   def __init__(self, fxn:Callable[..., ReturnType]):
line:   def add_buffer(self, b:Buffer) -> Buffer:
line:   def add(self, ei:ExecItem):
line:   def reset(self):
line:   def __get__(self, obj, objtype): return functools.partial(self.__call__, obj) # add support for instance methods
line:   def __call__(self, *args, **kwargs) -> ReturnType:
retu:   def __call__(self, *args, **kwargs) -> ReturnType:
retu: class TinyJit(Generic[ReturnType]):
line: from tinygrad.shape.symbolic import Variable                  # noqa: F401
line: from tinygrad.dtype import dtypes                             # noqa: F401
line: from tinygrad.helpers import GlobalCounters, fetch, Context   # noqa: F401
line: from tinygrad.device import Device                            # noqa: F401
retu: from tinygrad.device import Device                            # noqa: F401
